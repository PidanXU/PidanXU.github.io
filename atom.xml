<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stay foolish,stay hungry!</title>
  
  <subtitle>安卓程序分析 ctf reverse</subtitle>
  <link href="http://pidanxu.github.io/atom.xml" rel="self"/>
  
  <link href="http://pidanxu.github.io/"/>
  <updated>2022-10-05T17:55:32.697Z</updated>
  <id>http://pidanxu.github.io/</id>
  
  <author>
    <name>Xzhah</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试问题</title>
    <link href="http://pidanxu.github.io/2022/09/28/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>http://pidanxu.github.io/2022/09/28/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</id>
    <published>2022-09-28T07:47:30.000Z</published>
    <updated>2022-10-05T17:55:32.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web相关"><a href="#web相关" class="headerlink" title="web相关"></a>web相关</h1><h2 id="什么是ssrf攻击以及原理"><a href="#什么是ssrf攻击以及原理" class="headerlink" title="什么是ssrf攻击以及原理"></a><strong>什么是ssrf攻击以及原理</strong></h2><p>​    服务端请求伪造，攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送构造好的请求给服务器所在内网。比如可以用来端口扫描，file协议读文件。</p><p>​    一般是用户输入url，服务器帮忙解析资源，比如根据url下载图片，然后去抓包，通过修改url为内网的ip和端口，达到访问内网资源的目的。</p><p>​    如果探测到redis服务，默认情况下没有密码，就可以未授权执行命令（把反弹shell写进定时任务里），从而达到反弹shell的目的。</p><p>​    ssrf防护可以通过过滤返回信息、统一错误信息、限制请求的端口为常用端口、内网ip黑名单、禁用不需要的协议等方法。</p><h2 id="什么是csrf以及原理"><a href="#什么是csrf以及原理" class="headerlink" title="什么是csrf以及原理"></a><strong>什么是csrf以及原理</strong></h2><p>​    跨站请求伪造，一种挟持用户在当前已登录的Web上执行非本意操作的攻击方法。具体来说，比如用户已经登录了A网站，攻击者利用广告，链接等诱导用户打开B网站（比如把图片地址设置为攻击链接、js自动提交表单、构造一个诱惑链接），而B网站利用表单或者其他方式向A网站发送请求，就能通过身份验证执行操作。本质是利用了网站对用户网页浏览器的信任。</p><p>​    csrf的防护方式：</p><p>​    1）重要操作二次认证，防止操作在后台自动执行</p><p>​    2）设置会话的超时时间</p><p>​    3）操作类请求使用Post，浏览类请求使用Get。因为Post更安全，不会作为url的一部分，不会被缓存，并且可以被服务器日志记录</p><p>​    4）可以通过referer字段表明请求来源，服务端可以通过这个字段判断是否在合法的网站下发送的请求，用于同源检测。但是referer的内容来自于浏览器，各浏览器对referer的实现方法不同，可能有漏洞被利用。</p><p>​    5）在请求地址中加入token，攻击者只能利用用户的cookie信息，当HTTP请求中以参数的形式加入一个随机产生的token，并在服务端验证。比如token可以放在session中，每次请求就可以把session中的token拿出来与请求中的token对比。</p><p>​    6）跨域时不发送cookie</p><h2 id="http里为什么还要有host"><a href="#http里为什么还要有host" class="headerlink" title="http里为什么还要有host"></a><strong>http里为什么还要有host</strong></h2><p>​    host的目的是用来实现虚拟主机技术，即把一台完整的服务器分成若干个主机，可以在一个主机上运行多个网站或服务。因为http默认端口80，https默认端口443。这样的话根据一个ip来解析就不知道是访问哪个目录了。但是使用host请求头，就可以根据域名解析对应网站。</p><h2 id="xss"><a href="#xss" class="headerlink" title="xss"></a><strong>xss</strong></h2><p>​    跨站脚本攻击，是一种代码注入攻击，攻击者通过在目标网站上注入恶意脚本，使之在用户浏览器上运行，从而获取用户的Cookie等敏感信息。</p><p>​    该漏洞原理本质是攻击者的输入/参数中携带者恶意代码，而浏览器可能会把其解析为正常代码，从而执行。</p><p>​    xss可以分为三种：</p><p>​    存储型XSS：攻击者将恶意代码提交到目标网站的数据库中(通过论坛发帖、商品评论、用户私信)，用户打开目标网站时，网站服务端将恶意代码从数据库中取出，拼接在HTML中返回给浏览器。</p><p>​    反射型XSS：攻击者构造出特殊的URL，其中包含恶意代码。当用户打开url，恶意代码被取出，拼接在HTML中返回给浏览器。浏览器解析并执行恶意代码。</p><p>​    DOM型XSS：攻击者构造出特殊的URL，其中的恶意代码由前端的JS取出解析执行。</p><h2 id="socket的粘包和分包"><a href="#socket的粘包和分包" class="headerlink" title="socket的粘包和分包"></a><strong>socket的粘包和分包</strong></h2><p>​    粘包：如果两个包发送时间间隔很短，包长度足够长，那么发送的两个包内容可能在接收端那边就是合并到一个包里去了。这是socket的优化机制，可以降低内存开销。这时候就要考虑怎么把两个包的内容区分开了，有两种方法：1.给包的头尾都加上标记 2.在包头加上内容长度。</p><p>​    分包：如果socket包有长度限制，那么一个包的内容也可能会被拆分为多个包进行发送。同样可以靠1.给包的头尾都加上标记 2.在包头加上内容长度两种方式解决。</p><p><strong>xxe</strong></p><p><strong>poi</strong></p><p><strong>文件上传</strong></p><p><strong>文件包含</strong></p><p><strong>java反序列化</strong></p><h1 id="java相关"><a href="#java相关" class="headerlink" title="java相关"></a>java相关</h1><h2 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a><strong>ThreadLocal原理</strong></h2><p>​    ThreadLocal的目的是每个线程都有一份独立的局部变量，互相之间无法影响。与加锁不同之处在于，ThreadLocal会把传进来的变量每个线程都产生一个新的副本，从而互不影响。ThreadLocal的实现原理如下：<br>​    1）每个线程都维护了一个ThreadLocalMap对象，ThreadLocalMap由数组实现，采用开放定址法解决hash冲突（即如果发生了元素冲突的情况，就使用下一个槽位存储。因为使用了散列算法，所以地址分配得比较均匀，所以可以使用开放定址法）。与开放定址法作为对比的还有链表法，冲突的元素放到一个链表中，如HashMap。</p><p>​    2）ThreadLocalMap中存储着Entry对象，Entry中的key就是ThreadLocal对象，value是真正的值。Entry中的key是弱引用，其目的是当ThreadLocal不再被使用时，gc可以自动回收这个ThreadLocal对象，避免内存泄漏。但Entry中的value是强引用，所以在ThreadLocal的get,set,remove方法中都会检测是否有key变为null,进行对相应Entry的清理工作。所以建议每次用完ThreadLocal都做一次remove的调用。</p><p>​    建议将ThreadLocal作为静态对象使用，这样的话多个线程的ThreadLocalMap中共用一个ThreadLocal对象作为key,就可以操作线程自己的副本对象。如果把ThreadLocal作为示例对象就会每个线程里多创建一个对象，造成内存的浪费。</p><h2 id="gc回收机制"><a href="#gc回收机制" class="headerlink" title="gc回收机制"></a><strong>gc回收机制</strong></h2><p>​    gc回收机制中使用了两种判断对象是否可回收的策略：</p><p>​    1）引用计数法，当一个对象被创建后，每次被引用其对应的引用计数器就+1。当引用失效后，引用计数器就-1。这种方法的问题在于，如果两个或者多个对象之间存在循环引用的情况，引用计数就永远不会归0。所以只有早期JVM采用这个策略。</p><p>​    2）可达性分析，定义GC ROOT对象，然后从这些对象出发，得到所有的可达对象。Java中可以作为GC ROOT的对象有：a）虚拟机栈中的引用对象，如局部变量。b）方法区中的静态属性对象，方法区中常量引用对象。c）本地方法栈中(Native方法)引用的对象。</p><p>​    三种经典的gc回收算法是：</p><p>​    1）标记-清除法：最基础的收集算法，由<strong>标记</strong>和<strong>清除</strong>两个步骤组成。由上面的可达性分析找出所有的不可达对象，然后对所有标记的对象原地清除。这种方法的缺点在于回收完后会有很多不连续的内存空间。</p><p>​    2）复制算法：复制算法的思路是把内存区域分为两块：S0,S1，每次只使用其中一块内存如S0，当使用完触发gc时，便把S0上存活的对象移到S1上面去。然后把S0上的全部清理掉。这样也保证了内存的连续性，并且标记和复制可以同步进行。缺点就是内存减小了一半。</p><p>​    3）标记-整理法：该方法解决了标记-清除算法中内存不连续的问题，在完成标记步骤后，该算法会把存活的对象全都向前移动。然后将边界以外的内存全部清理掉。该算法的缺点在于效率会低于标记-清除法。</p><p>​    堆中分为年轻代、老年代、永久代三个部分：</p><p>​    1）年轻代是存活周期比较短的对象，分为Eden、S0、S1三个区域。一开始对象都在年轻代的Eden区域，当Eden区放满了或者对象太大无法再放进Eden区时，此时对年轻代（Eden和S0）进行一次minor gc，存活的对象放进S1中，然后清空Eden和S0，因为年轻代中存活的对象数量通常少，所以此时用复制算法开销较低。每次年轻代经历了minor gc存活下来的对象年龄会+1，到了一定岁数(通常15)就可以进入老年代。以及S1满了的话对象也可以进入老年代。</p><p>​    2）老年代中再满了就会出发full gc，或者System.gc()也可能会触发full gc 。此时就使用标记-清除法或者标记整理法。也可以使用两者结合，先多次标记-清除，等碎片太多了再用标记-整理。</p><p>​    在java语言中提供了四种垃圾回收器：</p><p>​    1）串行垃圾回收器：串行垃圾回收器会暂停所有的应用程序线程，然后采用单独的线程进行GC。</p><p>​    2）并行垃圾回收器：JVM的默认垃圾回收器，相较于串行回收性能有所提升，也需要暂停有所程序线程，但是会多线程进行gc。</p><p>​    3）并发标记扫描垃圾回收器：在初始标记时暂停其他线程，然后在可达性分析过程中恢复应用线程。但这在实时性上可能出问题，因为应用中对象的引用是在不断更新的。然后是重新标记，即把并发标记时产生变动的对象的存活标记进行修正，这需要暂停其他线程。最后是并发清除，此时可以恢复其他线程。</p><p>​    4）G1垃圾回收器：G1中各代（年轻代、老年代、永久代）的存储地址不连续，其会维护一个优先级列表，每次在收集时间内优先回收价值最大的Region。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a><strong>引用类型</strong></h2><p>​    1）强引用，在java中使用最广泛的，如Object o = new Object()这一类。只要强引用还在，gc永远不会回收被引用的对象。</p><p>​    2）软引用，用来描述有用但是非必须的对象。对于软引用，在系统内存不足时会对其进行回收。这种可以用来缓存相关进行处理。</p><p>​    3）弱引用，当gc扫描到只有弱引用时，不管内存是否充足都会回收。比如ThreadLocal，如果不使用弱引用，其会等到线程结束才被回收，但是有的线程生命周期可能远长于ThreadLocal的生命周期。</p><p>​    4）虚引用，任何时候gc都可以回收虚引用，不会对生命周期构成任何影响。虚引用必须和引用队列关联使用，其作用在于这个对象被gc回收时可以收到一个系统通知，也就是说如果gc要回收一个虚引用时，会把它加入到相应的引用队列，如果程序发现某个虚引用已经加入到引用队列，就可以在其被回收之前进行相应工作。比如管理直接内存（堆以外内存，jvm自动管理的范围是堆内存），就会用虚引用来进行清理工作。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a><strong>线程池</strong></h2><p>​    1）线程池的意义：线程池使得线程可以被复用，当线程执行完任务又可以返回线程池领取新任务执行。同时线程池可以更好管理线程，无论是控制线程数量还是控制线程状态。</p><p>​    2）线程池重要概念：<strong>corePoolSize</strong>，核心线程大小，线程池一直运行核心线程就不会停止，核心线程就是线程池里一直要复用的线程，非核心线程是当核心线程满了，阻塞队列也满了，临时顶上去的任务线程，后续没任务了是要回收的，所以非核心线程不会一直被复用。<strong>maximumPoolSize</strong>，线程池最大线程数，非核心线程数量=maximumPoolSize - corePoolSize。<strong>keepAliveTime</strong>，空闲线程存活时间，如果线程空闲下来，超过这个时间还没有任务执行，则会结束该线程。但是这里只回收非核心线程。<strong>workQueue</strong>，阻塞队列，线程池中的线程数量大于核心线程的数量时，就把新建的任务加入阻塞队列。<strong>RejectedExecutionHandler</strong>，饱和策略，如果阻塞队列满了，线程数也达到了最大线程数，线程池会根据饱和策略来执行后续操作，默认的策略就是丢掉任务抛出异常，还有三种是callerRunsPolicy（谁往线程池里丢这个任务就谁负责，一般是主线程），DiscardOldestPolicy（放弃阻塞队列中最旧的任务，然后把该线程加入阻塞队列），DiscardPolicy（丢掉任务，不报异常）。</p><p>​    3）线程池可以用submit和execute两种方法去启动任务，execute只能提交Runnable类型任务，submit既能提交Runnable类型又能提交Callable类型任务。execute碰到异常会直接抛出，并且execute是没有重量级锁的。submit会吃掉异常，通过Future的get方法可以将异常重新抛出。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>​    <strong>单例模式</strong>：单例模式下的类只有一个实例，类的构造函数为私有函数以保证该类无法被其他代码实例化。在自己的类构造过程中实例化自己，提供get()方法让其他代码获取自己的唯一实例。也可以在get()方法里实例化，这样可以起到lazy初始化的效果。也可以在类构造过程中写一个静态类Holder，其内部成员INSTANCE是单例类的实例化对象。然后在get方法中访问Holder.INSTANCE也能起到lazy加载的效果，并且还是线程安全。</p><p>​    <strong>工厂模式</strong>：定义一个创建对象的接口，让其子类自行决定要实例化哪一个工厂类。比如暴露一个getXXX(String type)，可以根据type的内容选择实例化哪一个子类，不过这些子类需要实现相同的接口或者继承自相同的父类。</p><p>​    <strong>抽象工厂模式</strong>：抽象工厂就是创建工厂的工厂。</p><p>​    <strong>建造者模式</strong>：把复杂对象拆分为多个零件对象实现，分为Product（产品）、AbstractBuilder（抽象构建者）、ConcreteBuilder（具体构建者）、Director（指挥者）。以StringBuilder为例，StringBuilder中Appendable为抽象建造者，定义了建造方法append, AbstractStringBuilder实现了Appendable接口的方法所以是具体构建者，StringBuilder重写了AbstractStringBuilder的append方法并以特定顺序对AbstractStringBuilder的append方法进行调用，所以既是具体建造者又是指挥者。另外提一下，StringBuffer的建造者模式和StringBuilder是一样的，只不过StringBuffer加了synchrozed关键字是线程安全的。</p><h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a><strong>jvm</strong></h2><p>​    包括内存管理、解释执行、JIT、classLoader、gc。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>​    jvm将内存划分为以下几个区域：</p><p>​    1）程序计数器：程序计数器的作用可以看作当前线程所指向字节码的行号指示器，在JVM中需要执行字节码解释工作，就会通过程序计数器来选取下一条字节码指令。占据较小的内存空间，是线程私有。</p><p>​    2）虚拟机栈：Java方法执行的内存模型，每个方法执行的时候会创建一个栈帧，用于存储局部变量、操作栈、动态链接、方法出口等信息。每个方法从被调用到执行完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。StockOverflowError错误代表着，该栈的深度过深，大于规定的深度（如递归一直调用下去），就会抛出该错误。线程私有。</p><p>​    3）本地方法栈：本地方法栈服务于native方法，与虚拟机栈的作用相似。本地方法接口可以通过本地方法接口来访问虚拟机内部的运行时信息。线程私有。</p><p>​    4）堆：java内存中最大的一块，被所有线程共享的一片区域。堆的目的是存放对象实例，几乎所有的对象实例都在这里分配内存。但是随着JIT编译器的发展和逃逸分析技术的成熟，栈上分配、标量替换优化技术使得“所有对象在堆上分配内存”不那么绝对了。</p><h3 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><p>​    为了提高热点代码的执行效率，在运行时，JIT（即时编译器）会把java字节码编译成本地机器码，并进行各层次的优化，保存到内存中。重点有C1编译器（局部优化，短时程序）、C2编译器（长期优化），方法内联优化、逃逸分析，栈上分配、标量替换等。</p><h1 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h1><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a><strong>进程与线程的区别</strong></h2><p>​    进程是资源的容器，把资源集中到一起，而线程是在CPU上被实际调度的实体对象。<strong>进程</strong>是资源分配的基本单位，包括可执行的代码、打开的文件描述符、挂起的信号、进程的状态、内存地址空间、以及一个或多个执行线程。而<strong>线程</strong>是进程中的活动对象，CPU调度的基本单位，每个线程拥有自己独立的程序计数器、线程栈、寄存器。</p><p>​    为什么有了进程还需要线程？因为一个进程中会有多个任务，如果只有一个调度单位，那么任务被阻塞时其他任务无法继续进行。因此需要有多个独立的调度单位来并发的完成这些任务。另一方面，线程比进程更加的轻量级，可以更快被创建、切换。因为进程中拥有大量资源，所以每次切换进程需要保存资源导致切换开销大。</p><p>​    在Linux内核中，并没有把进程和线程进行区分，线程就是一种特殊的进程，都被叫做任务。都是使用task_struct结构体表示、调用fork函数，由clone方法创建。</p><h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a><strong>进程间通信方式</strong></h2><p>​    1）匿名管道通信：管道是半双工，数据只能由一个方向流动。如果双方都需要通信，那么就需要建立两个管道。且管道只能用于父子进程或者兄弟进程之间。管道对于管道两端的进程来说，就是一个文件，但它不是普通文件，其单独构成一种文件系统，只存在于内存之中。</p><p>​    管道实质上是一个内核缓冲区，进程以先进先出的方式从缓冲区中存取文件，一端存，一端取。管道的局限在于其只支持单向数据流、只能用于有亲缘关系的进程中、没有名字用以标志、管道的缓冲区有限、管道传送的是无格式字节流导致管道两端需要事先约定好数据格式。</p><p>​    2）有名管道通信：有名管道提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样即使不存在亲缘关系的进程也可以通过该路径访问管道通信。有名管道把名字放在文件系统中，内容放在内存中。</p><p>​    所以管道（无论是否有名）本质就是一种特殊类型的文件，用于先进先出的读写。</p><p>​    3）信号量：信号量的本质是一个计数器，用于多进程对共享数据对象的存取，不以传输数据为主要目的，而是以保护共享资源作为主要目的，使得资源在一个时刻只能被一个进程独享。常作为一种锁机制作为进程间以及同一进程内不同线程之间的同步手段。比如可以用于买票场景，每次办理一次业务，信号量就-1，信号量为0时就是没有车票了，进程便挂起。    </p><p>​    4）消息队列：消息队列是在两个不相关进程间传递数据的一种方式，本质是一种消息链表，可以独立于独写两端，即使进程终止消息队列也不会消失。且消息队列可以有优先级，可以随机读取，每个消息队列在内核中由队列ID进行标志。</p><p>​    5）共享内存：共享内存是两个或多个进程共享同一块内存。最快的一种IPC，因为进程是直接对内存进行存取。因为多个进程同时操作，所以需要处理同步问题，信号量与共享内存常结合在一起使用。所以服务器和客户端进行通信可以由共享内存+信号量+消息队列共同实现</p><p>​    6）套接字：socket可以在本地单机的跨进程通信，也可以在不同计算机上通过网络连接完成跨进程通信。套接字是支持TCP/IP的网络通信的基本操作单元。套接字的特性由3个属性组成：域、端口、协议。域指定传播介质，最常用的是AF_INET，表示使用英特网，第二种常见的是AF_UNIX，表示UNIX文件系统。同一主机的不同进程被赋予了不同端口号。套接字协议在因特网中有三种：a)流套接字：通过TCP/IP实现，提供一个有序、可靠、双向字节流的连接。而且有出错后重发机制。b)数据报套接字：不需要建立连接与维持连接，通过UDP/IP实现，对发送长度有限制。数据报作为一个单独的网络消息被传输，可能出现丢失、乱序等情况，因为UDP不是一个可靠协议，但是速度快。c)原始套接字：可以操纵较低层次的协议，如IP，ICMP。</p><p>​    在套接字中TCP是没有长度限制的，因为TCP是基于流的协议，但是一般由于链路层的数据帧是1500字节限制，IP数据包则是1500-IP头的大小限制(8)。一般TCP的长度不要超过IP数据包内容长度(1500-IP头-TCP头)，这样就不需要对单个TCP包进行分割。</p><h2 id="共享内存相关的文件夹"><a href="#共享内存相关的文件夹" class="headerlink" title="共享内存相关的文件夹"></a><strong>共享内存相关的文件夹</strong></h2><h2 id="kill信号，以及Linux信号"><a href="#kill信号，以及Linux信号" class="headerlink" title="kill信号，以及Linux信号"></a><strong>kill信号，以及Linux信号</strong></h2><p>​    -9是无条件终止，不加-9默认是SIGTERM,以正常方式来终止。ctrl c会发送SIGINT信号，当cpu从内核切回到用户态，就会处理该信号，该信号的默认处理动作是结束进程。ctrl+z是SIGSTP，ctrl+\是SIGOUT，SIGOUT在程序终止后会产生core dump文件。</p><p>​    信号是用来通知进程发生了异步事件。1-31是不可靠信号，34-64是可靠信号，这是因为linux的信号部分继承自unix,而unix因为早期设计导致信号可能会丢失（比如同时来N个信号，但是进程只能处理一个），所以linux在后续中引入了可靠信号32-64，进程无法及时处理的信号会去排队（双链表队列里等着），修复了信号丢失问题，但早期的信号就没法修复了。</p><p>​    信号的发送可以由键盘按键、系统调用、硬件异常、程序错误、kill命令等方式进行生产与发送。</p><p>​    信号的检测时机在内核态切换到用户态时检测，把未决信号（存在pending里，发送过来还没处理的信号）传递给用户态进行处理。进程也可以选择屏蔽某些信号，这些信号就会进入阻塞状态。</p><p>​    信号的处理有两种：默认处理（如终止，终止+dump，忽略）、自定义。</p><h2 id="namespace与cgroup"><a href="#namespace与cgroup" class="headerlink" title="namespace与cgroup"></a><strong>namespace与cgroup</strong></h2><h2 id="execve与system的区别"><a href="#execve与system的区别" class="headerlink" title="execve与system的区别"></a><strong>execve与system的区别</strong></h2><h2 id="docker相关"><a href="#docker相关" class="headerlink" title="docker相关"></a>docker相关</h2><h2 id="docker建议禁用的syscall"><a href="#docker建议禁用的syscall" class="headerlink" title="docker建议禁用的syscall"></a><strong>docker建议禁用的syscall</strong></h2><p>add_key: 阻止容器使用不在命名空间的内核密钥环</p><p>bpf：拒绝将潜在的持久性bpf程序加载到内核中</p><p>clone：拒绝clone新的namespace</p><p>create_module：不能在容器中对内核模块进行操作</p><p>kexec_load：不能在容器中加载内核模块并执行</p><p>…</p><h2 id="docker逃逸"><a href="#docker逃逸" class="headerlink" title="docker逃逸"></a><strong>docker逃逸</strong></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;web相关&quot;&gt;&lt;a href=&quot;#web相关&quot; class=&quot;headerlink&quot; title=&quot;web相关&quot;&gt;&lt;/a&gt;web相关&lt;/h1&gt;&lt;h2 id=&quot;什么是ssrf攻击以及原理&quot;&gt;&lt;a href=&quot;#什么是ssrf攻击以及原理&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="others" scheme="http://pidanxu.github.io/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>android study 17 hook dynamic load dex</title>
    <link href="http://pidanxu.github.io/2022/08/12/android-study-17-hook-dynamic-load-dex/"/>
    <id>http://pidanxu.github.io/2022/08/12/android-study-17-hook-dynamic-load-dex/</id>
    <published>2022-08-12T05:53:07.000Z</published>
    <updated>2022-08-12T05:58:00.994Z</updated>
    
    <content type="html"><![CDATA[<p>## </p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><p><a href="https://bbs.pediy.com/thread-229597.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-229597.htm</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;## &lt;/p&gt;
&lt;h2 id=&quot;references&quot;&gt;&lt;a href=&quot;#references&quot; class=&quot;headerlink&quot; title=&quot;references&quot;&gt;&lt;/a&gt;references&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://bbs.pediy.</summary>
      
    
    
    
    
    <category term="android" scheme="http://pidanxu.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android study 16 about context</title>
    <link href="http://pidanxu.github.io/2022/08/07/android-study-16-about-context/"/>
    <id>http://pidanxu.github.io/2022/08/07/android-study-16-about-context/</id>
    <published>2022-08-06T17:07:52.000Z</published>
    <updated>2022-08-09T14:19:57.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>​    在网上看到一个比较形象的比喻，装饰类可以比作一个画框，目标类比作一幅画。黄框可以有自己新增的功能，画框和画是相互独立的，不会耦合，画框可以动态的扩展画的功能(比如挂在墙上)。</p><p>举例：</p><p>​    首先实现一个画的接口： interface Paint。然后实现它的实体类：ShitPaint implement Paint。然后需要创建一个Shape接口的抽象装饰类：PaintDecorator implemebt Paint，并且需要持有Pait的实现对象。最后创建实体装饰类RedPaintDecorator extends PaintDecorator ，新增自己的功能。</p><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>​    android中context可以说是频繁出现，但是这个context到底是个什么呢？它是应用和系统的桥梁，是应用访问系统资源的接口，也可以认为是应用所持有的安卓王国凭证。</p><p>​    Context是安卓系统提供的一个抽象类，通过它可以访问系统资源，调用应用程序级操作，获取全局信息。有了Context，开发者才可以：弹出一个toast，启动一个Activity，获取程序布局文件，访问数据库。这些操作都需要和系统交互，java类只有在有了context类过后，才能成为组件，才有了组件的功能。</p><p>​    涉及Context一般有两种用法：调用Context的方法，或者调用接口时需要Context参数。这些行为意味着需要访问系统相关资源。Context从何而来？来自AMS，AMS是系统级进程，他有系统级操作的能力。应用程序受AMS调控，在程序启动的过程中，AMS会把一个“凭证”跨进程通信传给应用。程序把这个凭证封装成Context，并提供一系列接口。这样的好处是，应用程序级的操作，都在系统的调控下进行，系统可以限制各种情景下的权限，同时防止恶意攻击。</p><p>​    Application类的context和Activity的context权利是不同的，生命周期也不一样。Activity开放给用户也只有部分有限的权利，开发者要获取Context也只能从Activity,Application等组件中获取。</p><h2 id="Context家族"><a href="#Context家族" class="headerlink" title="Context家族"></a>Context家族</h2><p>​    Context及其子类情况：最顶层是Context抽象类，定义了一系列与系统交互的接口。ContextWrapper是Context的子类，但是并不会直接实现Context的接口，而是把接口的实现托管给ContextImpl，ContextImpl是Context接口的实现者。AMS的凭证也在ContextImpl中，然后把ContextImpl赋值给ContextWrapper。这里就会用到<strong>装饰者模式</strong>。Application和Service继承自ContextWrapper,也就可以调用Context的接口。Activity更特殊，他有界面，所以需要一个主题。ContextThemeWrapper在ContextWrapper的基础上增加与主题相关的操作。Activity继承了ContextThemeWrapper。</p><p>​    这样设计的优点：运用装饰者模式，向外屏蔽ContextImpl的内部逻辑，同时如果ContextImpl的内部实现改变了，也不会影响ContextWrapper。并且扩展也很方便，比如Service和Activity的情景不同，需要的接口方法也不同，但是与系统交互的接口相同。使用装饰者模式就可以扩展出很多特定的功能，只需要把ContextImpl赋值给装饰器类就行。</p><h2 id="Context分类"><a href="#Context分类" class="headerlink" title="Context分类"></a>Context分类</h2><p>​    Context最终的实现类有：Application,Activity,Service三类，ContextImpl会被这三者持有，这三类有何不同呢？</p><p>​    Appilcation只有一个，且是全局Context，可以访问包信息等资源。Application Context生命周期长，整个应用程序运行期间都会存在。同时开发者可以自定义实现Application，做一些全局的初始化操作。但是注意不要把Application当成工具类给全局使用。</p><p>​    Activity继承自ContextThemeWrapper，试一个拥有主题的context对象。Activity常用于与UI有关的操作，常规可以直接使用activity.this。</p><p>​    Service继承自ContextWrapper，也可以直接使用service.this使用context，且service没有界面，不需要主题。</p><p>​    Provider使用Application的context,Receiver使用Activity的context。这是为什么呢？因为Provider是伴随着应用启动创建的，在这时候Application被初始化后会赋值给Provider，这时候Provider就拥有context了。而Receiver是哪个组件创建广播，则context便是哪个组件，这是注册过程中决定的。所以一般是Acvtivity中创建，那么Receiver的context一般也就是activity了。</p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><p><a href="https://segmentfault.com/a/1190000038357455#:~:text=%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%8A%BD%E8%B1%A1%E7%B1%BB,%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BA%A7%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82" target="_blank" rel="noopener">https://segmentfault.com/a/1190000038357455#:~:text=%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%8A%BD%E8%B1%A1%E7%B1%BB,%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BA%A7%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82</a></p><p><a href="https://www.runoob.com/design-pattern/decorator-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/decorator-pattern.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;&lt;h3 id=&quot;装饰器模式&quot;&gt;&lt;a href=&quot;#装饰器模式&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="android" scheme="http://pidanxu.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android study 15 sandbox</title>
    <link href="http://pidanxu.github.io/2022/08/04/android-study-15-sandbox/"/>
    <id>http://pidanxu.github.io/2022/08/04/android-study-15-sandbox/</id>
    <published>2022-08-04T10:01:33.000Z</published>
    <updated>2022-08-06T16:54:12.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android安全模型"><a href="#android安全模型" class="headerlink" title="android安全模型"></a>android安全模型</h1><h2 id="android沙箱模型"><a href="#android沙箱模型" class="headerlink" title="android沙箱模型"></a>android沙箱模型</h2><p>​    对于android来说，沙箱模型就是进程隔离和权限管理那一套。每个android应用在安装时被PMS赋予独特的用户标志(UID)，一个用户ID识别一个应用程序，根据这个id来决定应该允许还是限制程序访问设备资源。每个应用程序都独立运行在虚拟机的沙箱进程中。</p><p>​    android沙箱可以用来实现应用程序之间的分离，以允许或拒绝一个应用程序访问资源，为了达到这个目的，android会使用一些Linux实用工具，比如与用户相关的用户和组ID，以及权限，来实现程序被允许的操作。</p><p>​    Android应用进程运行在各自的进程上，被分配唯一的用户ID，运行在基本沙箱进程中的应用程序没有被分配权限，因而防止了此类应用访问资源。但是Android程序可以通过manifest来申请权限，或者与其他受信任的应用运行在同一进程中，从而共享其数据和代码。</p><p>​    不同应用想在一个进程中，首先使用相同私钥签名，然后在manifest里给他们申请分配相同的用户id，这可以通过用相同的值/名定义 manifest 属性 android:sharedUserId 来做到。</p><h3 id="Android系统分区与加载"><a href="#Android系统分区与加载" class="headerlink" title="Android系统分区与加载"></a>Android系统分区与加载</h3><p>​    Android设备的分区包括系统分区，数据分区，Cache分区，以及SD卡分区，具体如下：</p><p>​    1.系统分区通常是只读分区，里面有系统内核，系统函数库，应用框架，系统应用程序等。是厂商在出厂时写入。当出现安全问题时，可以进入安全模式，只加载系统分区不加载数据分区，隔离第三方应用带来的风险。</p><p>​    /system/app目录存放系统自带应用</p><p>​    /system/lib存放系统库函数</p><p>​    /system/bin与/system/xbin存放系统管理命令</p><p>​    /system/framework存放安卓框架的jar文件</p><p>​    2.数据分区用来存储用户数据与应用程序，出现安全问题时可以不加载数据区，或者直接将数据区格式化。</p><p>​    /data/data存放apk程序的数据，每个APK在/data/data/apk-package目录下有自己专属目录，只能在该目录中进行操作。</p><p>​    /data/app存放用户安装的apk</p><p>​    /data/system下存放了packages.xml，packages.list，appwidgets.xml等文件，记录安装的软件以及widget信息。</p><p>​    /data/misc下存放了WIFI账号，VPN设置等信息</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://cloud.tencent.com/developer/article/1799705" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1799705</a></p><p><a href="http://images.china-pub.com/ebook3800001-3805000/3800568/ch02.pdf" target="_blank" rel="noopener">http://images.china-pub.com/ebook3800001-3805000/3800568/ch02.pdf</a></p><p><a href="https://github.com/cckenny/2020_autumn_mobile_security_interview/blob/main/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8.md" target="_blank" rel="noopener">https://github.com/cckenny/2020_autumn_mobile_security_interview/blob/main/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8.md</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;android安全模型&quot;&gt;&lt;a href=&quot;#android安全模型&quot; class=&quot;headerlink&quot; title=&quot;android安全模型&quot;&gt;&lt;/a&gt;android安全模型&lt;/h1&gt;&lt;h2 id=&quot;android沙箱模型&quot;&gt;&lt;a href=&quot;#androi</summary>
      
    
    
    
    
    <category term="android" scheme="http://pidanxu.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android study 14 java基础</title>
    <link href="http://pidanxu.github.io/2022/08/02/android-study-14-java%E5%9F%BA%E7%A1%80/"/>
    <id>http://pidanxu.github.io/2022/08/02/android-study-14-java%E5%9F%BA%E7%A1%80/</id>
    <published>2022-08-02T07:35:11.000Z</published>
    <updated>2022-08-04T08:29:21.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java的三大特性"><a href="#java的三大特性" class="headerlink" title="java的三大特性"></a>java的三大特性</h2><p><strong>继承</strong></p><p>​    继承允许开发者可以创建分等级层次的类，子类可以继承父类的特征和行为。</p><p><strong>多态</strong></p><p>​    多态是同一个接口，实例不同，执行的操作也不同。主要优点如下：</p><p><strong>封装</strong></p><p>​    封装是将代码及其处理的数据绑定在一起的一种编程机制，该机制保证了程序和数据都不受外部干扰且不被误用。封装的目的在于保护信息，使用它的主要优点如下：</p><pre><code>1. 保护类中的信息，它可以组织在外部定义的代码随意访问内部代码和数据。2. 隐藏细节信息，不需要开发者修改和使用的信息，被保护起来，开发者只需要知道如何使用即可。3. 有助于各个系统之间解耦，提高系统的独立性。4. 提高软件复用率，降低成本。每个封装单位都是相对独立的整体</code></pre><p>​    java基本的封装单位是类，由于类的用途是封装复杂性，所以类的内部有隐藏实现复杂性的机制。Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西，私有的方法数据只能通过该类的成员代码来访问，这就可以确保不会发生不希望的事情。</p><h2 id="java的特点"><a href="#java的特点" class="headerlink" title="java的特点"></a>java的特点</h2><p>​    除了以上说的面向对象特点，java还有以下特点：</p><p>​    1.平台无关性，java虚拟机保证了java”一次编译，到处运行“的特点</p><p>​    2.支持多线程，java语言自身提供了多线程支持</p><p>​    3.支持网络编程且方便</p><p>​    4.编译与解释并存</p><h2 id="JVM-JDK-JRE"><a href="#JVM-JDK-JRE" class="headerlink" title="JVM,JDK,JRE"></a>JVM,JDK,JRE</h2><p>​    JDK是Java Development Kit的缩写，是功能齐全的Java SDK, 它拥有JRE所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><p>​    JRE是Java Runtime Environment的缩写，它是运行已编译Java程序所需内容的集合，包括java虚拟机，java类库，java命令和其他基础构件，但是JRE不能用来创建新程序。</p><p>​    JDK包含JRE，JRE包含JVM。</p><h2 id="Oracle-JDK和Open-JDK"><a href="#Oracle-JDK和Open-JDK" class="headerlink" title="Oracle JDK和Open JDK"></a>Oracle JDK和Open JDK</h2><p>​    1.OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是OpenJDK 的一个实现，并不是完全开源的</p><p>​    2.Oracle JDK更稳定，它经过了更多测试以及有更多的类和一些错误修复，它经过了系统性的测试。</p><p>​    3.性能方面，Oracle提供了更好的性能</p><h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><p>​    值传递：指在方法调用时，传递的参数是按值得拷贝，传递的是值的拷贝，也就是说传递后就互不相关了。</p><p>​    引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的是引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p><p>​    java基本类型作为参数被传递时肯定是值传递；引用类型作为参数被传递时也是值传递，只不过“值”为对应的引用。</p><h3 id="为什么重写equals方法必须重写hashcode方法"><a href="#为什么重写equals方法必须重写hashcode方法" class="headerlink" title="为什么重写equals方法必须重写hashcode方法"></a>为什么重写equals方法必须重写hashcode方法</h3><p>​    判断两个对象是否相等，是先判断hashcode是否相同，相同再根据equals进行判断，如果只重写了equals方法，不重写hashcode方法，可能造成hashcode判断是不同的，但是equals认为是相同得。</p><p>​    在java得一些容器中(如Set容器)，不允许有两个完全相同的对象，插入的时候判断相同则会进行覆盖，这时候如果只重写了equals（）的方法，而不重写hashcode的方法，Object中hashcode是根据对象的存储地址转换而形成的一个哈希值。这时候就有可能因为没有重写hashcode方法，造成相同的对象散列到不同的位置而造成对象的不能覆盖的问题。</p><h3 id="String与StringBuilder"><a href="#String与StringBuilder" class="headerlink" title="String与StringBuilder"></a>String与StringBuilder</h3><p>​    String对象是不可变的，StringBuilder和StringBuffer是可变的。对于已经存在的String修改都是重新建一个新的对象，然后把新的值传进去。String可以理解为常量，则是线程安全的，StringBuilder是非线程安全的，StringBuffer对方法加了同步锁，是线程安全的。</p><p>​    String为什么是不可变的呢？</p><p>​    1.因为java字符串池的设计，在Java中，由于会使用大量的字符串常量，如果每次声明就创建一个对象，会造成空间浪费，Java提出了String pool的概念，在堆中开辟一块存储空间String pool，当初始化一个String变量时，如果该字符串已经存在了，就不会去创建一个新的字符串变量，而是会返回已经存在了的字符串的引用。如果字符串是可变的，某一个字符串变量改变了其值，那么其指向的变量的值也会改变，String pool将不能够实现！</p><p>​    2.使得线程安全</p><p>​    在并发场景下，多个线程同时读一个资源，是安全的，不会引发竞争，但对资源进行写操作时是不安全的，不可变对象不能被写，所以保证了多线程的安全。</p><p>​    3.避免安全问题</p><p>​    在网络连接和数据库连接中字符串常常作为参数，例如，网络连接地址URL，文件路径path，反射机制所需要的String参数。其不可变性可以保证连接的安全性。如果字符串是可变的，黑客就有可能改变字符串指向对象的值，那么会引起很严重的安全问题。</p><p>​    4.加快字符串处理速度</p><p>​    由于String是不可变的，保证了hashcode的唯一性，于是在创建对象时其hashcode就可以放心的缓存了，不需要重新计算。这也就是Map喜欢将String作为Key的原因，处理速度要快过其它的键对象。所以HashMap中的键往往都使用String。</p><h3 id="gc机制"><a href="#gc机制" class="headerlink" title="gc机制"></a>gc机制</h3><p>​    gc是一种回收空间避免内存泄露的机制，当JVM内存紧张，通过执行gc有效回收，转而分配给新对象从而实现内存的再利用。</p><p>​    <strong>如何标记不再被引用的对象</strong></p><p>​    目前有两种方法：引用计数法和可达性分析法。引用计数在对象头分配与一个字段，用来存储该对象的引用计数，一旦被引用就+1，这个引用失效就-1。对于技术为0的就可以回收。但是碰到对象之间存在循环引用就会出现问题，对象可能已经不再使用，但是对象内部还在相互引用，导致无法回收。第二种就是做个可达性分析，首先按规则找出当前活跃的引用，从这些GC Roots引用出发，遍历对象引用关系图，将可达的引用都标记为存活。比如方法中的局部变量，静态变量，常量，都可以在一开始被视为活跃引用。</p><p>​    <strong>在哪里回收垃圾</strong></p><p>​    java内存区域可以分为：堆，方法区，虚拟机栈，本地方法栈，程序计数器。</p><p>​    方法区与堆都是线程共享的区域，这两部分占用 <code>JVM</code> 大部分内存，剩下三个小弟将会跟线程绑定，随着线程消亡，自动将会被 <code>JVM</code> 回收。</p><p>​    <strong>如何回收</strong></p><p>​    1.标记-清除法：最简单暴力的方法，通过上述 <code>GC Roots</code> 标记出可达对象。把所有标记了的对象清理掉，存在的问题是，可能会产生很多碎片化内存，因为这些对象并不是连续的，实际分配过程，由于没有连续内存，导致虚拟机感知到内存不足，又不得不提前再次触发 <code>GC</code>。另一个问题是标记与清除效率比较低。这就竟会导致 <code>GC</code> 占用时间过长，影响正常程序使用。</p><p>​    2.复制算法：这个方法会将内存分为两块，每次只使用其中一块，当这一块内存使用完毕，触发gc，就会把还存活的对象复制到另外一块内存上。这个算法每次只需要操作一半内存，<code>GC</code> 回收之后也不存在任何空间碎片，新对象内存分配时只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。但是这个算法闲置一半内存空间，空间利用效率不高。</p><p>​    3.标记-整理算法：标记-整体法也是通过 <code>GC Roots</code> 标记存活对象。将存活对象往一端移动，按照内存地址一次排序，然后将末端边界之外内存直接清理。这个算法问题是效率不高。</p><p>​    <strong>trade-off</strong></p><p>​    1.可以看到，上面三种算法并没有十分完美的解决方案，所以只能做的是综合利用各种算法特点将其作用到不用的内存区域。目前商业虚拟机会根据对象存活周期不同，划分不同的内存区域。新生代每次 <code>GC</code> 之后都可以回收大批量对象，所以比较适合复制算法，只需要付出少量复制存活对象的成本。这里内存划分并没有按照 1:1 划分，默认将会按照 8:1:1 划分成 <code>Eden</code> 与两块 <code>Survivor</code>空间。每次使用 <code>Eden</code> 与一块<code>Survivor</code>空间，这样我们只是闲置 10% 内存空间。不过我们每次回收并不能保证存活对象小于 10%,在这种情况下就需要依靠老年代的内存分配担保。当<code>Survivor</code>空间并不能保存剩余存活对象，就将这些对象通过分配担保进制移动至老年代。</p><p>​    老年代中对象存活率将会特别高，且没有额外空间进行分配担保，所以并不适合复制算法，所以需要使用标记-清除或标记-整理算法。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://www.jianshu.com/p/7687559d29a3" target="_blank" rel="noopener">https://www.jianshu.com/p/7687559d29a3</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;java的三大特性&quot;&gt;&lt;a href=&quot;#java的三大特性&quot; class=&quot;headerlink&quot; title=&quot;java的三大特性&quot;&gt;&lt;/a&gt;java的三大特性&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    继承允许开发者可以创</summary>
      
    
    
    
    
    <category term="android" scheme="http://pidanxu.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android study 13</title>
    <link href="http://pidanxu.github.io/2022/07/26/android-study-13/"/>
    <id>http://pidanxu.github.io/2022/07/26/android-study-13/</id>
    <published>2022-07-25T16:09:54.000Z</published>
    <updated>2022-08-02T07:31:26.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android中进程与线程"><a href="#android中进程与线程" class="headerlink" title="android中进程与线程"></a>android中进程与线程</h1><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><p>1.线程是CPU调度的最小单元，同时线程本身是一种有限的系统资源</p><p>2.进程是一个执行单元，安卓中一个应用就是一个进程。进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU调度和分配的基本单位，是比进程更小的能独立运行的基本单位，线程本身不拥有系统资源（除了必不可少的资源如程序计数器、寄存器、栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p><p>3.线程与进程主要差别在于是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的健壮，但是多进程在切换时，资源耗费大，效率要差。</p><h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>​    我们知道，安卓应用启动流程中，实际是Zygote负责fork出子进程，并且执行ActivityThread.main()方法，main方法的调用就是在主线程/UI线程中。</p><p>​    主线程负责向UI组件分发事件（包括绘制事件），在这个进程中，安卓应用和安卓组件发生交互。所以主线程也叫做UI线程。系统不会为每个组件单独创建线程，在同一个进程里的UI组件都会在UI线程中实例化，系统对每一个组件的调用都从UI线程中分发出去。</p><p>​    响应系统回调的方法，比如响应用户的onKeyDown和各种生命周期回调，都是在UI线程里运行。</p><p>​    那么很容易理解，主线程是不能被阻塞的，应该把耗时任务放到单独的线程中去完成(如工作线程/后台线程)</p><h2 id="安卓进程分类"><a href="#安卓进程分类" class="headerlink" title="安卓进程分类"></a>安卓进程分类</h2><p>安卓进程按应用组件及组件状态可以分为五个重要性等级:</p><p>1.前台进程：当前进程正在被用户请求服务的进程，满足以下条件：</p><p>​    *包含一个Activity正在和用户交互(Resume状态下)</p><p>​    *包含一个绑定到Activity的Service，这个Activity正在和用户交互</p><p>​    *包含一个前台Service，Service 调用了startForeground()方法</p><p>​    *包含一个正在执行onReceive的Receiver</p><p>前台进程优先级最高，是最后杀掉的对象。</p><p>2.可见进程：不包含前台组件，但是包含用户可见组件的进程(但是不可交互)，满足以下条件：</p><p>​    *包含一个Activity处于onPause状态</p><p>​    *包含一个Service，这个Service绑定了可见Activity</p><p>3.Service进程：一个进程包含了Service，但是不包含前两种级别组件的进程</p><p>4.后台进程：一个进程包含Activity，但是这个Activity不再对用户可见，例如一个应用处于onStop状态。</p><p>5.空进程：进程中不存在活动组件。这种进程存在的目的是缓存作用，下次启动该应用时直接启动该进程。</p><p>因为一个运行着 service 的进程优先级比一个运行着后台 activity 的优先级高，这就是为什么要使用一个 service 来处理一个耗时的操作会比简单开启一个工作线程来处理要好的原因。也是为啥在广播中开启线程来处理操作比不上启动一个 service 来操作更保险的原因。</p><p><strong>进程依赖</strong></p><p>​    如果进程A依赖进程B，那么进程B的优先级永远更高。比如进程B的provider给进程A提供数据，或者进程B的Service给进程B某个组件绑定了。</p><h2 id="安卓进程间通信方式对比"><a href="#安卓进程间通信方式对比" class="headerlink" title="安卓进程间通信方式对比"></a>安卓进程间通信方式对比</h2><p>1.Intent通信，简单易用，但是只支持Bundle所支持的数据类型，用于四大组件间的进程间通信</p><p>2.文件共享，简单易用，但不适合高并发的场景，简单数据共享且无高并发场景使用</p><p>3.AIDL，功能强大，支持一对多并发实时通信，但是需要注意线程同步问题，用于复杂的进程间调用。</p><p>4.Messenger，比AIDL简单易用，但是只支持1对多串行实时通信，可以用于简单的进程间通信场景</p><p>5.ContentProvider，强大的数据共享能力，可以通过call方法扩展，受约束的AIDL，主要对外提供数据的CRUD操作，用于进程间大量数据共享的场景。</p><p>6.RemoteViews, 跨进程访问UI方面很有用，比较小众的通信方式，可以用于某些特殊场景</p><p>7.Socket，跨主机，通信范围广，但是只能传输字节流，常用于网络通信中</p><h2 id="linux进程调度"><a href="#linux进程调度" class="headerlink" title="linux进程调度"></a>linux进程调度</h2><p>​    操作系统是应用程序和可用资源之间的媒介，如内存，cpu，物理设备都是资源，调度器使得同时执行多个程序成为可能，可以让应用程序共享CPU。调度器讲CPU的时间片有效分配给应用程序，这其中会面临一些问题，比如要为关键实时任务最小化响应时间, 又要最大限度地提高 CPU 的总体利用率。</p><p>​    <strong>linux进程的分类</strong></p><p>​    当涉及有关调度的问题时, 传统上把进程分类为”I/O受限(I/O-dound)”或”CPU受限(CPU-bound)”。</p><p>​    另外一种分类法把进程区分为三类: 交互式进程，批处理进程，实时进程</p><p>​    在linux中, 调度算法可以明确的确认所有实时进程的身份, 但是没办法区分交互式程序和批处理程序(统称为普通进程), linux2.6的调度程序实现了基于进程过去行为的启发式算法, 以确定进程应该被当做交互式进程还是批处理进程. 当然与批处理进程相比, 调度程序有偏爱交互式进程的倾向。</p><p>​    根据进程的不同分类Linux采用不同的调度策略。对于实时进程，采用FIFO或者Round Robin的调度策略。对于普通进程，则需要区分交互式和批处理式的不同。传统Linux调度器提高交互式应用的优先级，使得它们能更快地被调度。而CFS和RSDL等新的调度器的核心思想是”完全公平”。这个设计理念不仅大大简化了调度器的代码复杂度，还对各种调度需求的提供了更完美的支持.</p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><p><a href="https://www.cnblogs.com/mengdd/p/3418780.html" target="_blank" rel="noopener">https://www.cnblogs.com/mengdd/p/3418780.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;android中进程与线程&quot;&gt;&lt;a href=&quot;#android中进程与线程&quot; class=&quot;headerlink&quot; title=&quot;android中进程与线程&quot;&gt;&lt;/a&gt;android中进程与线程&lt;/h1&gt;&lt;h2 id=&quot;进程与线程的区别&quot;&gt;&lt;a href=&quot;#进</summary>
      
    
    
    
    
    <category term="android" scheme="http://pidanxu.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android study 12-lifecycle</title>
    <link href="http://pidanxu.github.io/2022/07/23/android-study-12-lifecycle/"/>
    <id>http://pidanxu.github.io/2022/07/23/android-study-12-lifecycle/</id>
    <published>2022-07-23T02:31:00.000Z</published>
    <updated>2022-07-23T16:01:54.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="1-Activity生命周期"><a href="#1-Activity生命周期" class="headerlink" title="1. Activity生命周期"></a>1. Activity生命周期</h2><p>Activity生命周期图如下：</p><img src="/2022/07/23/android-study-12-lifecycle/activity.png"><h3 id="1-1-Activity状态"><a href="#1-1-Activity状态" class="headerlink" title="1.1 Activity状态"></a>1.1 Activity状态</h3><p>Activity只有三种状态可以长期保持，其他状态都是过渡作用。</p><p>1）运行状态(Resumed):</p><p>​    当前Activity在最上方，用户可以与它进行交互。也就是running状态。此状态由onResume进入，onPause退出。</p><p>2）暂停状态(Paused):</p><p>​    当前Activity仍然可见，但是在最上方的是其他Activity，最上方的activity是半透明的，或者是部分覆盖整个屏幕。被暂停的activity不会再接受用户的输入。</p><p>​    该Activity仍然处于活着的状态，Activity对象存留在内存，保持着所有的状态和成员信息，仍然吸附在window manager</p><p>​    当处于低内存状态时，系统会杀掉该进程，释放空间。</p><p>​    此状态由onPause进入，可能由onResume或者onCreate重新唤醒，或者被onStop结束。</p><p>3）停止状态(Stopped)</p><p>​    当前activity处于后台，完全不可见</p><p>​    处于活着的状态，资源和状态仍然保留，不再吸附在window manager</p><p>​    只要有内存需要，系统就会清理该Activity以释放资源</p><p>​    该状态由onStop进入。由onReStart或者onCreate重新唤醒。或者onDestroy彻底结束。</p><h3 id="1-2-额外的相关方法"><a href="#1-2-额外的相关方法" class="headerlink" title="1.2 额外的相关方法"></a>1.2 额外的相关方法</h3><p>​    <strong>onSaveInstanceState</strong>：当Activity停止时，系统会调用该方法，可以把状态信息保存到实例状态Bundle中，此方法的默认实现保存有关 Activity 视图层次结构状态的瞬时信息，例如 <a href="https://developer.android.com/reference/android/widget/EditText" target="_blank" rel="noopener"><code>EditText</code></a> 微件中的文本或 <a href="https://developer.android.com/reference/android/widget/ListView" target="_blank" rel="noopener"><code>ListView</code></a> 微件的滚动位置。</p><p>​    重建先前被销毁的 Activity 后，可以从系统传递给 Activity 的 <a href="https://developer.android.com/reference/android/os/Bundle" target="_blank" rel="noopener"><code>Bundle</code></a> 中恢复保存的实例状态。<a href="https://developer.android.com/reference/android/app/Activity#onCreate(android.os.Bundle" target="_blank" rel="noopener"><code>onCreate()</code></a>) 和 <a href="https://developer.android.com/reference/android/app/Activity#onRestoreInstanceState(android.os.Bundle" target="_blank" rel="noopener"><code>onRestoreInstanceState()</code></a>) 回调方法均会收到包含实例状态信息的相同 <a href="https://developer.android.com/reference/android/os/Bundle" target="_blank" rel="noopener"><code>Bundle</code></a>。</p><p>​    因为无论系统是新建 Activity 实例还是重新创建之前的实例，都会调用 <a href="https://developer.android.com/reference/android/app/Activity#onCreate(android.os.Bundle" target="_blank" rel="noopener"><code>onCreate()</code></a>) 方法，所以在尝试读取之前，必须检查状态 Bundle 是否为 null。如果为 null，系统将新建 Activity 实例，而不会恢复之前销毁的实例。</p><p>​    <strong>onRestoreInstanceState</strong>：在onStart后调用，也是回复状态目的。</p><h2 id="2-Service生命周期"><a href="#2-Service生命周期" class="headerlink" title="2. Service生命周期"></a>2. Service生命周期</h2><p>Service生命周期图如下：</p><h3 id="2-1-启动方式"><a href="#2-1-启动方式" class="headerlink" title="2.1 启动方式"></a>2.1 启动方式</h3><p>​    service有两种启动方式，不同的方式决定了Service具有两种生命周期。</p><p>​    1.start方式：onCreate -&gt; onStartCommand。onDestroy释放资源</p><p>​    2.bind方式：onCreate -&gt; onBind。需要相关的client调用unbindServie()后才能释放资源:onUnBind(),onDestroy。</p><p>​    Service 的生命周期比 Activity 的要简单很多。但关注其如何创建销毁反而更加重要，因为服务可以在用户没有意识到的情况下在后台运行。</p><p>​    Service 的生命周期可以遵循两条不同的途径：</p><ul><li><p>启动服务<br> 该服务在其他组件中调用 <a href="https://link.jianshu.com?t=https://developer.android.com/reference/android/content/Context.html#startService(android.content.Intent" target="_blank" rel="noopener">startService()</a>) 时创建，然后无限运行，必须通过 <a href="https://link.jianshu.com?t=https://developer.android.com/reference/android/app/Service.html#stopSelf(" target="_blank" rel="noopener">stopSelf()</a>) 来自行停止运行。此外，其他组件也可以通过调用 <a href="https://link.jianshu.com?t=https://developer.android.com/reference/android/content/Context.html#stopService(android.content.Intent" target="_blank" rel="noopener">stopService()</a>) 来停止服务。服务停止后，系统会将其销毁。</p></li><li><p>绑定服务<br> 该服务在另一个组件（客户端）调用 <a href="https://link.jianshu.com?t=https://developer.android.com/reference/android/content/Context.html#bindService(android.content.Intent,android.content.ServiceConnection,int" target="_blank" rel="noopener">bindService()</a>) 时创建。然后客户端通过 <a href="https://link.jianshu.com?t=https://developer.android.com/reference/android/os/IBinder.html" target="_blank" rel="noopener">IBinder</a> 接口与 Service 进行进行通信。客户端可以通过调用 <a href="https://link.jianshu.com?t=https://developer.android.com/reference/android/content/Context.html#unbindService(android.content.ServiceConnection" target="_blank" rel="noopener">unbindService()</a>) 来关闭连接。多个客户端可以绑定到相同服务，而且当所有绑定全部取消后，系统会销毁该服务。（不必调用 <a href="https://link.jianshu.com?t=https://developer.android.com/reference/android/content/Context.html#stopService(android.content.Intent" target="_blank" rel="noopener">stopService()</a>) 来停止服务)</p><p>这两种方式是可以共存的，比如使用startService启动后台播放音乐，随后用户想要加入控制播放器获取歌曲信息，Activity就可以通过bindService绑定服务获取信息。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生命周期&quot;&gt;&lt;a href=&quot;#生命周期&quot; class=&quot;headerlink&quot; title=&quot;生命周期&quot;&gt;&lt;/a&gt;生命周期&lt;/h1&gt;&lt;h2 id=&quot;1-Activity生命周期&quot;&gt;&lt;a href=&quot;#1-Activity生命周期&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="android" scheme="http://pidanxu.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android study 11</title>
    <link href="http://pidanxu.github.io/2022/07/14/android-study-11/"/>
    <id>http://pidanxu.github.io/2022/07/14/android-study-11/</id>
    <published>2022-07-14T08:11:41.000Z</published>
    <updated>2022-07-21T04:08:22.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android系统启动流程和app启动流程"><a href="#android系统启动流程和app启动流程" class="headerlink" title="android系统启动流程和app启动流程"></a>android系统启动流程和app启动流程</h1><h3 id="1-android系统架构以及启动流程"><a href="#1-android系统架构以及启动流程" class="headerlink" title="1. android系统架构以及启动流程"></a>1. android系统架构以及启动流程</h3><p>android系统从上到下可以分为：应用层，框架层，Native层，硬件抽象层，linux内核层。</p><img src="/2022/07/14/android-study-11/jiagoutu.png"><ol><li><strong>loader层</strong>：当按下电源后，引导芯片会从固化在ROM中的预设代码开始执行，然后加载引导程序<strong>BootLoader</strong>到RAM中。引导程序会把系统os运行起来，并初始化一些硬件参数功能</li><li><strong>kernel层</strong>：这一层会启动linux内核，这个内核里包括了内存模型，进程调度，权限安全等服务。内核层中主要启动两个进程：swapper进程(pid=0)，又叫idle进程，系统初始化kernel从无到有的第一个进程。用于初始化内存管理，进程管理，同时加载屏幕硬件，相机硬件等。kthredd进程，会创建内核中的一些线程，以及内核守护进程。内核进程的功能一般需要虚拟机去调用.</li><li><strong>硬件抽象层</strong>：属于kernel和硬件之间的接口层，这个是为了保护厂商的知识产权。硬件厂商可以把硬件驱动放在这一层，然后去访问内核里的东西，比如控制硬件的部分。这一层会隐去具体接口实现细节，只提供接口。这些接口用来响应硬件设备的一些模块，比如蓝牙模块，WIFI模块等。</li><li><strong>Native层</strong>： 这一层分为两部分：C/C++程序库，比如SQLite,SSL,libc之类的。android运行时库，包括核心库和虚拟机。核心库就是Java语言的一些核心库功能，虚拟机就是dalvik/art。之前说了swapper/idle进程启动，然后会启动init进程，<strong>init</strong>进程就是native这一层的。init进程主要会做这些事：1）用户守护进程，用来周期性做一些事。2）启动一些重要服务，比如开机动画。3）孵化zygote进程，所有应用由zygote孵化出来。4）孵化media server进程，用来启动和管理c++ framework，比如相机服务。</li><li><strong>java框架层</strong>：主要是提供应用所需要的API。顺着上一层继续说，zygote启动后会做以下事情：1）创建服务端socket，为后续进程通信做准备。2）加载虚拟机。 3）fork system server进程，zygote fork的第一个进程，负责启动和管理java framwork层，包括ActivityManagerService,PackageManagerService，WindowManagerService、binder线程池等等。4）fork第一个应用程序-launcher。launcher是anroid系统中的Home程序，主要用来现实系统中已安装的应用程序。launcher应用程序的启动会通过请求packageManagerService返回系统中已经安装的应用信息，并将这些应用信息通过封装处理成快捷列表显示在系统屏幕上，这样用户就可以单击启动它们。</li></ol><img src="/2022/07/14/android-study-11/qidong.jpeg"><img src="/2022/07/14/android-study-11/load_liucheng.png"><h2 id="2-app应用启动流程"><a href="#2-app应用启动流程" class="headerlink" title="2.app应用启动流程"></a>2.app应用启动流程</h2><p>​    1）launcher会首先向system_server进程(最终由进程中的activityManagerService)发送启动activity的进程间通信请求。(Binder方式)</p><p>​    2）ams保存下来要启动的activity信息，然后给launcher发送中止状态的进程间通信请求，launcher收到后就会进入终止状态，并且给ams发送已进入终止状态的请求。(Binder方式)</p><p>​    3）ams开始执行启动activity，如果当前进程中没有activity对应的进程，就会通过socket给zygote进程发送一个进程间通信请求，zygote会fork出一个应用进程，也就是复制一个虚拟机实例。(Socket方式)</p><p>​    4）进程启动后，首先实例化ActivityThread，执行其main函数，创建ApplicationThread，Looper，Handler对象。并开启主线程消息循环Looper.loop()。ActivityThread main里会调用attach方法进行Binder通信，通知system_server进程执行<code>ActivityManagerService#attachApplication(mAppThread)</code>方法，把自己注册到ams中，用于初始化Application和Activity。</p><p>​    5）在system_server进程中，ActivityManagerService#attachApplication(mAppThread)依次初始化Application和Activity，调用接口IApplicationThread<code>#</code>bindApplication接口通知主线程Handler创建Application对象，绑定Context，执行Application#onCreate生命周期函数(开发者能控制的第一行代码)。</p><p>​    6）框架<code>system_server</code>进程最终是通过ActivityStackSupervisor.realStartActivityLocked()方法，最终会调用scheduleTransaction方法，通过 sendMessage 给 ActivityThead 的 Handler 发送一个 EXECUTE_TRANSACTION 消息。消息处理函数最终会调用performLaunchActivity，调用Instrumentation的callActivityOnCreate方法，启动Activity执行 Activity#onCreate() 生命周期。</p><img src="/2022/07/14/android-study-11/app_start.png"><h3 id="2-1-zygote进程"><a href="#2-1-zygote进程" class="headerlink" title="2.1 zygote进程"></a>2.1 zygote进程</h3><p>​    1. 把开机android系统启动过程中与zygote有关的展开详细说的话。首先native层启动的init函数具体负责以下工作：</p><p>​        1）开机画面</p><p>​        2）文件系统的创建和挂载</p><p>​        3）孵化zygote进程</p><p>​        4）启动ServiceManger，它是Binder服务管理器，管理所有android的系统服务。</p><ol start="2"><li><p>init进程会fork启动zygote进程，具体以下工作：</p><p>1）创建server端的socket，负责和客户端通信</p><p>2）预加载类和资源，提高应用启动速度</p><p>3）启动SystemServer进程</p><p>4）监听socket，当有应用要启动时，就会向它发出请求。</p><ol start="3"><li><p>SystemServer负责以下工作：</p><p>1）启动binder线程池，这是SystemServer与其他进程沟通的方式</p><p>2）初始化Looper</p><p>3）创建了SystemServiceManager对象，它会启动Android中的各种服务。包括AMS、PMS、WMS</p><p>4）启动桌面进程，这样才能让用户见到手机的界面。</p><p>5）开启loop循环，开启消息循环，SystemServer进程一直运行，保障其他应用程序的正常运行。</p></li></ol></li></ol><h3 id="2-2-android-binder机制"><a href="#2-2-android-binder机制" class="headerlink" title="2.2 android binder机制"></a>2.2 android binder机制</h3><p>​    AMS和ActivityThread主要通过进程间通信。AMS 会通过 Application 来和 ActivityThread 进行进程间通信。跨进程通信的机制就是把数据从本地进程和空间地址传输至远程空间和地址。Binder的好处是只用复制一次，性能高于消息队列等其他方式，其本质是两个进程不同的逻辑地址对应相同的物理地址。</p><p>​    App进程与SystemServer进程通过Binder机制进行进程间通信，Android中有两个相关的接口：</p><p>​    1）IApplicationThread: 作为系统进程请求应用进程的接口</p><p>​    2）IActivityManager: 作为应用进程请求系统进程的接口</p><p>​    对于一个Binder接口，在客户端和服务端各有一个实现，Native和Proxy，它们之间的通信通过transcat和onTranscat触发，Nativexxx就是自身进程的Binder代理类，Proxy是远程进程的Binder代理类。</p><p>​    如之前所说，这些Binder都是由ServiceManger管理(init进程孵化而来)，ServiceManger管理android所有的系统服务，可以认为ServiceManager是Binder机制里的DNS服务器，客户端如果想使用某个服务，调用相应的getSystemService接口，ServiceManager就会通过Binder名称找到并且返回对应服务的Binder对象。</p><h3 id="2-3-服务端-IActivityManager"><a href="#2-3-服务端-IActivityManager" class="headerlink" title="2.3 服务端: IActivityManager"></a>2.3 服务端: IActivityManager</h3><p>​    ActivityManagerNative作为服务端的“桩(Stub)”，其主要职责就是对远程传递过来的数据进行反序列化;</p><p>​    ActivityManagerProxy作为服务的“代理(Proxy)”，运行在客户端，其主要职责就是将数据进行序列化，再传递给远程的“桩(Stub)”</p><p>​    App使用AMS提供的功能，比如startActivity，是通过AMS在客户端的代理ActivityManagerProxy发起的。</p><p>​    最下面一层是桩(Stub)的具体实现——AMS(ActivityManagerService)，负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作。</p><h3 id="2-4-客户端：IApplicationThread"><a href="#2-4-客户端：IApplicationThread" class="headerlink" title="2.4 客户端：IApplicationThread"></a>2.4 客户端：IApplicationThread</h3><p>​    桩(Stub)：ApplicationThreadNative</p><p>​    代理(Proxy)：ApplicationThreadProxy，App在客户端进程中实现了实例化Activity、调用onCreate等生命周期函数的功能，因为跨进程也不能被AMS直接调用，而是AMS通过客户端的代理ApplicationThreadProxy来处理。</p><p>​    最下面一层是桩(Stub)的具体实现——ApplicationThread，它是ActivityThread的一个内部类，ApplicationThread负责响应系统进程发起的请求，而实际触发的业务逻辑是在ActivityThread中。与一般的代理模式不同，它不是直接持有ActivityThead的一个引用，而是把处理的请求发到ActivityThread内部的一个Handler上。</p><p>​    ActivityThread是应用启动C/S模式中的客户端，包含了应用进程主线程的全部机制：1.启动应用的主线程，开启消息循环。2. 提供了一个IActivityThread接口作为与AMS通讯接口，通过该AMS将Activity的状态变化传递到客户端的Activity对象。</p><h3 id="2-5-Application的初始化"><a href="#2-5-Application的初始化" class="headerlink" title="2.5 Application的初始化"></a>2.5 Application的初始化</h3><p>​    在ActivityThread创建的时候，会将自己的ApplicationThread绑定到AMS中。ApplicationThread是 ActivityThread 的一个内部类，是一个 Binder 对象。上面说到AMS#attachApplication会初始化Application和Activity，这个过程具体如下：</p><p>​    1）在ActivityThread创建的时候，会将自己的ApplicationThread绑定到AMS中。应用进程作为客户端通过IActivityManager接口发起跨进程调用，这样AMS#attachApplication会被执行。该函数会把应用进程传过来的IApplication实例保存在系统进程维护的ProcessRecord中，这样一来AMS后续可以通过IApplicationThread实例发起应用进程的调用。</p><p>​    2）在attachApplication过程中，会有一些信息要传递给应用进程，以便应用进程的初始化，如解析AndroidManifest.xml得到的数据结构ApplicationInfo，这时候就会通过IApplication接口的bindApplication来通知主线程创建Application对象，绑定Context，调用Application.onCreate。</p><h3 id="2-6-Activity的初始化"><a href="#2-6-Activity的初始化" class="headerlink" title="2.6 Activity的初始化"></a>2.6 Activity的初始化</h3><p>​    <code>ActivityManagerService#attachApplication(mAppThread)</code>里依次初始化了Application和Activity，其中的<code>mStackSupervisor#attachApplicationLocked(ProcessRecord)</code>里进行了Activity的初始化。</p><p>​    AMS通过ActivityRecord来维护Activity运行时的状态信息，需要将Activity绑定到AMS中的ActivityRecord。在Activity类中有一个IBinder类型的属性：<code>private IBinder mToken;</code>，IBinder类型表示这个属性是一个远程对象的引用，Token持有了一个ActivityRecord实例的弱引用。在创建一个ActivityRecord的时候，就会创建了一个Token类型的对象。</p><p>​    系统进程维护ActivityRecord，应用进程维护Activity，两者之间的映射关系就是利用Token来维系。在发生Activity切换时,应用进程会将上一个Activity的Token(AMS.startActivity()的输入参数resultTo)传递给系统进程，系统进程会根据这个Token找到ActivityRecord，对其完成调度后，再通知应用进程：Activity状态发生了变化。</p><h3 id="2-7-Binder机制"><a href="#2-7-Binder机制" class="headerlink" title="2.7 Binder机制"></a>2.7 Binder机制</h3><p>​    Binder用于进程间通信，但linux内核已经有了管道，消息队列，共享内存，Socket等IPC机制，那为什么android还要提供Binder?原因是从性能，安全性，稳定性三个方面考虑。</p><p>​    1）性能，一句话来说Binder由于只需要一次数据拷贝，所以性能上占据优势，仅次于共享内存。Socket是一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机进程间低速通信。而管道和消息队列采用的是存储-转发模式，即先把数据从发送方缓存区拷贝到内核缓存区，然后接收方再从内核缓存区拷贝到自己的进程缓存区。这期间就发生了两次拷贝。共享内存虽然无需拷贝，但是控制复杂，难以使用。Binder只需要把数据拷贝到内核缓存区后，给内核缓存区以及接收进程用户空间之间建立映射关系(不同逻辑地址对应相同物理地址)，这样无需第二次拷贝，接收进程也就可以访问到发送的数据了。</p><p>​    2）稳定性，Binder是基于C/S架构，客户端有什么需求就丢给服务端完成，大家各司其职，互相独立。所以从稳定性上来说，Binder是优于共享内存的。</p><p>​    3）安全性，传统IPC无法获得对方可靠的UID/PID，无法鉴别身份，因为传统IPC是由用户在数据包中填入PID/UID。其次传统IPC访问接入点是开放的，只要知道接入点程序就可以建立连接。而Binder 驱动程序将发送者进程的 UID 和 PID 添加到每个事务。 因此，由于系统中的每个应用具有其自己的 UID，所以该值可以用于识别调用方。 调用的接收者可以检查所获得的值并且决定是否应该完成事务。</p><h3 id="2-8-Binder通信模型"><a href="#2-8-Binder通信模型" class="headerlink" title="2.8 Binder通信模型"></a>2.8 Binder通信模型</h3><p>​    这个通信模型中一共有四个参与者：Client,Server,ServiceManager/Binder驱动。其中只有Binder驱动运行在内核空间，其他都在用户空间。ServiceManager和Binder驱动由系统提供，Client和Server由程序提供。</p><p>​    <strong>Binder驱动</strong></p><p>​    Binder驱动如同路由器一样，是整个通信的核心，驱动负责进程之间Binder通信的建立，Binder的传递，计数管理，数据包在进程之间的交互等一系列底层支持。</p><p>​    <strong>ServiceManager与实名Binder</strong></p><p>​    ServiceManager与DNS类似，作用是将字符串形式Binder名字转成该Binder的实体引用。注册了名字的Binder叫实名Binder, Server在创建Binder后，会为他起一个字符串形式，可读易记的名字。将这个Binder实体连同名字一起通过Binder驱动发送给ServiceManager。ServiceManager会维护相关信息。</p><p>​    ServiceManager与Client/Service通信也是通过Binder, ServiceManager是服务端，他也有Binder实体，且这个实体不需要注册也没有名字。当一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体。且这个Binder在其他进程中都是0号引用。</p><p>​    Client通过0号Binder向ServiceManager通过名称获取Binder实体。</p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><p><a href="https://juejin.cn/post/6844904116561379341" target="_blank" rel="noopener">https://juejin.cn/post/6844904116561379341</a></p><p><a href="https://www.jianshu.com/p/37370c1d17fc" target="_blank" rel="noopener">https://www.jianshu.com/p/37370c1d17fc</a></p><p><a href="https://www.jianshu.com/p/c95c208774c2" target="_blank" rel="noopener">https://www.jianshu.com/p/c95c208774c2</a></p><p><a href="https://weishu.me/2016/01/12/binder-index-for-newer/" target="_blank" rel="noopener">Binder学习指南 | Weishu’s Notes</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;android系统启动流程和app启动流程&quot;&gt;&lt;a href=&quot;#android系统启动流程和app启动流程&quot; class=&quot;headerlink&quot; title=&quot;android系统启动流程和app启动流程&quot;&gt;&lt;/a&gt;android系统启动流程和app启动流程&lt;/</summary>
      
    
    
    
    
    <category term="android" scheme="http://pidanxu.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android study 10 so load</title>
    <link href="http://pidanxu.github.io/2022/07/09/android-study-10-so-load/"/>
    <id>http://pidanxu.github.io/2022/07/09/android-study-10-so-load/</id>
    <published>2022-07-09T13:48:16.000Z</published>
    <updated>2022-07-13T12:38:39.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android-so加固"><a href="#android-so加固" class="headerlink" title="android so加固"></a>android so加固</h1><h2 id="1-so加固简介"><a href="#1-so加固简介" class="headerlink" title="1. so加固简介"></a>1. so加固简介</h2><p>​    因为so逆向的难度比dex逆向难度更大，所以开发者常常会把核心算法(加解密，协议)放在native实现。这时候就需要对so进行加固保护。</p><p>​    so加固分为有源so加固和无源so加固。有源的so加固：自解密，混淆，源码VMP等。无源保护则是对so加壳，vmp保护等。</p><p>​    有源保护中的自解密就是先把要加密的函数给加密了，然后加载so文件，在运行的时候把加密的数据给解密。还有一种比较常见的是ollvm，通过指令膨胀，虚假指令，控制流平坦化等方式可以混淆代码达到保护的目的。而vmp就是自己写一个解释器，对自定义的指令进行解释执行，不过对性能影响较大。</p><p>​    无源码保护的加壳，其核心是自定义linker。在壳被执行后还原出原来的so文件，最后把控制流交还给被保护的so文件，该方法成本低，对性能影响小，但是也相对容易攻破。</p><h2 id="2-so加载原理"><a href="#2-so加载原理" class="headerlink" title="2. so加载原理"></a>2. so加载原理</h2><p>​    so有执行视图和链接视图。链接视图以Section为单位访问各段数据，编译链接过程会用section信息去读取相关数据。执行视图则是程序加载执行过程中访问的方式。so加固则是根据so执行流程以及所依赖的数据结构进行拆解，加密和重组的。</p><p>​    so加载流程如下：</p><p>​    1）dl_open会调用find_library -&gt; find_loaded_library_by_soname，从内存中查找已经加载的so文件，如果有已经加载的直接返回handler。</p><p>​    2）如果没有已加载的so，则执行加载，并且新建soinfo结构体，将so加载到内存中。</p><p>​    3）执行预加载prelink_image，读取so文件中dynamic字段的内容，初始化重定位需要的数据。</p><p>​    4） 执行link_image，修复内存中的数据，完成重定位，调用call_constructors构造函数</p><p>​    5） 执行so的init和init_array中的函数</p><p>​    从以上流程可以知道，在重定位完成以前，so中的代码是不会被执行的，代码都在linker中执行。以及so中最先执行的函数是init, 其次是init_array。所以有很多加固会利用init,init_array中的函数来进行解密。或者利用JNI_OnLoad函数，但这种方式只适用于Android下特殊的so。</p><h2 id="3-so的加固"><a href="#3-so的加固" class="headerlink" title="3.so的加固"></a>3.so的加固</h2><p>​    UPX加固方法：只加固代码段。数据段和重定位的相关结构都保留在文件中，利用插入的init节对代码进行解密。本质上和Section加密类似，只是放大了加密范围，并添加修改init节的操作。</p><p>​    自实现linker方法：重定位过程需要自己实现，带来的好处是可以破坏so的结构或者自定义so的结构。</p><h2 id="4-ollvm混淆"><a href="#4-ollvm混淆" class="headerlink" title="4.ollvm混淆"></a>4.ollvm混淆</h2><p>​    llvm分为三段式：Frontend、Optimizer、backend。前端负责词法分析，语法分析，语义分析，生成中间代码等。然后进入optimizer优化环节,比如死代码去除，编译器内联等操作。最后就是bankend后端环节，核心是根据中间语言ir生成和CPU匹配的机器码。</p><p>​    混淆这个操作就是在optimizer这个环节进行的：</p><p>​    1. 字符串加密，逐行扫面ir中的字符串，对这些字符串进行逐字节异或。</p><pre><code>2. 指令膨胀，会把简单的指令膨胀为功能相同，但是逻辑上更复杂的指令。我看网上对这个反混淆的思路有人把二进制反过来提升为llvm ir指令，然后用llvm自己的优化把这种指令膨胀的混淆和不可达路径给干掉。。。 3. 虚假控制流，加入额外的条件跳转和不可达基本块，达到干扰控制流分析的目的。解决思路的话，可以考虑用符号执行/模拟执行遍历出所有的真实块，或者对跳转条件做分析？把恒定跳转的分支给定下来 4. 控制流平坦化，ollvm会添加一个用于控制跳转的状态变量和分发器，当真实块执行了过后就更新这个状态变量。然后分发器根据这个状态变量跳转到下一个真实块。如果原本的执行流程中存在条件跳转，则会在各条件下对状态变量设置不同的值，再回到分发器进行检查和跳转。就相当于做了一个大范围的switch。</code></pre><h3 id="4-2-去控制流平坦化"><a href="#4-2-去控制流平坦化" class="headerlink" title="4.2 去控制流平坦化"></a>4.2 去控制流平坦化</h3><p>​    首先我的观点是，ollvm的混淆其实都没啥很好的办法可以通用的自动化去混淆。原因是混淆指令和开发者指令之间没有明显边界，特别是编译器优化过后(比如把大switch优化成二分查找的if), 真的要调试还不如用脚本给所有真实块第一条指令下个断点来调试。</p><p>​    网上的帖子用符号执行/模拟执行来自动去控制流平坦化，其实大多都是需要对着样本特地写的，没法泛化使用，核心思想就是1）通过规则识别真实块，2）获取真实块之间的前后关系，3）patch二进制程序，重新连边。</p><p>​    <strong>识别真实块</strong></p><pre><code>1）函数的开始地址为序言的地址2）序言的后继为主分发器3）后继为主分发器的块为预处理器4）后继为预处理器的块为真实块5）无后继的块为retn块6）剩下的为无用块</code></pre><p>​    <strong>识别真实块前后关系</strong></p><p>​    主要需要处理的就是分支语句，这里就是把cmov涉及的状态设为true/false，分别获取两次的分支地址。</p><p>​    <strong>patch程序</strong></p><p>​    把无用块置为nop，没有分支的则直接jmp导向下一个真实块，分支的则把cmovz这样的改为jz,然后在后面新增jmp指向另一分支。</p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><p><a href="https://f5.pm/go-87511.html" target="_blank" rel="noopener">https://f5.pm/go-87511.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;android-so加固&quot;&gt;&lt;a href=&quot;#android-so加固&quot; class=&quot;headerlink&quot; title=&quot;android so加固&quot;&gt;&lt;/a&gt;android so加固&lt;/h1&gt;&lt;h2 id=&quot;1-so加固简介&quot;&gt;&lt;a href=&quot;#1-so加</summary>
      
    
    
    
    
    <category term="android" scheme="http://pidanxu.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android study 9 signature</title>
    <link href="http://pidanxu.github.io/2022/07/03/android-study-9-signature/"/>
    <id>http://pidanxu.github.io/2022/07/03/android-study-9-signature/</id>
    <published>2022-07-03T15:17:33.000Z</published>
    <updated>2022-07-05T03:56:31.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android签名机制"><a href="#android签名机制" class="headerlink" title="android签名机制"></a>android签名机制</h1><h2 id="1-初识android程序签名"><a href="#1-初识android程序签名" class="headerlink" title="1.初识android程序签名"></a>1.初识android程序签名</h2><p>​    在android系统中，所有安装到系统的应用必须有一个数字证书。这个数字证书用于标志程序作者，以及在应用程序之间建立信任关系。</p><p>​    <strong>签名的作用</strong></p><p>​    1） 签名可以证明apk的所有者，通过对Apk进行签名，开发者可以证明自己对apk的所有权与控制权。签名可用于程序的安装和更新，软件包管理器会同构签名证书和数字摘要来验证程序是否被篡改。</p><p>​    2） 有利于程序升级。当旧版本与新版本的数字证书相同时，android系统会认为这两个程序是同一个程序的不同版本。如果证书不同，系统则认为是两个不同的程序，会要求新程序更改包名。</p><p>​    3） 有利于程序的模块化设计，android系统允许拥有同一签名的程序运行在同一进程中，所以开发者可以分模块开发，用户只需要在需要的时候下载合适的模块即可。</p><p>​    4） 通过permission的方式在多个程序间共享数据和代码。如果某个权限(permission)的protectionLevel是signature，则这个权限就只能授予那些跟该权限所在的包拥有同一个数字证书的程序。</p><h2 id="2-签名的验证方式"><a href="#2-签名的验证方式" class="headerlink" title="2.签名的验证方式"></a>2.签名的验证方式</h2><p>​    发送者对文件计算摘要，然后用私钥签名。把密文，证书，公钥发送给接收端。接收端使用证书认证身份，然后用公钥解密，自己计算一遍摘要，对比摘要是否相同确保完整性。</p><h3 id="2-1-v1签名"><a href="#2-1-v1签名" class="headerlink" title="2.1 v1签名"></a>2.1 v1签名</h3><p>​    v1是基于jar签名，jarsigner            </p><p>​    首先META-INF目录下有3个和签名有关的文件</p><p>​    1）MANIFEST.MF：APK所有原始文件的数据摘要的base64编码，数据摘要算法一般就是SHA1或者SHA256。</p><p>​    2）CERT.SF: 首先计算MANIFEST.MF文件的数据摘要。然后base64编码记录在CERT.SF的文件头里。逐条计算MANIFEST.MF文件中每一个块的数据摘要，并经过BASE64编码后，记录在CERT.SF中的同名块中，属性的名字是“SHA1-Digest</p><p>​    3）CERT.RSA：把之前生成的CERT.SF文件用私钥计算出签名，然后将签名以及含公钥信息的数字证书一同写入CERT.RSA文件。</p><p>​    所以生成签名的过程就是:</p><p>​    1) 对APK内部所有文件，提取摘要后base64编码，生成指纹清单MANIFEST.MF</p><p>​    2) 对指纹清单的数据计算摘要，然后base64编码保存到CERT.SF文件主属性中，计算指纹清单文件内每一个数据块的数据摘要，编码后保存到CERT.SF的文件属性中</p><p>​    3）计算CERT.SF文件摘要，然后签名，最后把签名和证书一同保存到CERT.RSA文件中</p><p>​    <strong>v1签名的缺陷</strong></p><p>​    v1签名方案是不会保护到APK内所有内容的，并且验证时候不够迅速，需要先解压然后验证每个文件的摘要。因此就引入了v2方案</p><h3 id="2-2-v2签名"><a href="#2-2-v2签名" class="headerlink" title="2.2 v2签名"></a>2.2 v2签名</h3><p>​    v2签名是对APK本身进行摘要计算，那么则不需要解压APK的操作，减少了校验时间。并且针对整个APK的摘要计算，修改apk中任意一个文件都会不通过校验。</p><p>​    <strong>apk文件格式</strong></p><p>​    apk文件本质上是一个ZIP压缩包，而ZIP格式是固定的，主要由三部分构成：</p><p>​    1）内容块： 所有压缩文件都在这里面，每个压缩文件有一个local file header，主要会记录文件名，压缩算法，压缩前后大小，修改时间，CRC32值等。</p><p>​    2）中央目录：包含了多个central directory file header，和每个local file header一一对应。每个中央目录文件头主要记录了压缩算法，注释信息，local file header的偏移等。</p><p>​    3）最后是EOCD（end of central record），主要记录了中央目录大小和偏移，注释信息等。</p><p>​    v1只会校验内容块中的压缩文件。</p><p>​    v2会在apk中新增一个签名块，新的块中存了签名，摘要，签名算法，证书链等信息。APK签名块位于中央目录之前，文件数据之后。V2签名同时修改了EOCD中的中央目录的偏移，使得签名后的APK还符合ZIP结构。</p><p>​    v2方案会把APK分块签名，分成1M的块，计算每个块的摘要，以及针对所有摘要计算一个总摘要。再对总摘要进行签名。每个块的摘要，证书链，额外信息会类似一个MANIFEST.MF文件，然后计算这个文件的数字签名，形成类似SF文件，最后把“MF”和”SF”文件与公钥通过keystore签名后，形成签名块放入apk文件中。</p><h3 id="2-3-v3签名"><a href="#2-3-v3签名" class="headerlink" title="2.3 v3签名"></a>2.3 v3签名</h3><p>​    v2签名的问题在哪里呢？签名是默认25年有效期的，如果在签名过期或者密钥泄露想更换签名的情况下，不是那么方便，而v3在v2的基础上支持了密钥轮转。</p><p>​    具体来说，即v3可以在签名部分添加新的证书，在这个新块中，会记录之前的签名信息以及新的签名信息，以密钥转轮的方案，来做签名的替换和升级。这意味着，只要旧签名证书在手，开发者就可以通过它在新的 APK 文件中，更改签名。v3 签名新增的新块（attr）存储了所有的签名信息，由更小的 Level 块，以链表的形式存储。</p><p>​    其中每个节点都包含用于为之前版本的应用签名的签名证书，最旧的签名证书对应根节点，系统会让每个节点中的证书为列表中下一个证书签名，从而为每个新密钥提供证据来证明它应该像旧密钥一样可信。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://www.jianshu.com/p/145fb9ad6f07" target="_blank" rel="noopener">https://www.jianshu.com/p/145fb9ad6f07</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;android签名机制&quot;&gt;&lt;a href=&quot;#android签名机制&quot; class=&quot;headerlink&quot; title=&quot;android签名机制&quot;&gt;&lt;/a&gt;android签名机制&lt;/h1&gt;&lt;h2 id=&quot;1-初识android程序签名&quot;&gt;&lt;a href=&quot;#1-</summary>
      
    
    
    
    
    <category term="android" scheme="http://pidanxu.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android study 8</title>
    <link href="http://pidanxu.github.io/2022/07/01/android-study-8/"/>
    <id>http://pidanxu.github.io/2022/07/01/android-study-8/</id>
    <published>2022-07-01T15:25:51.000Z</published>
    <updated>2022-07-03T03:52:29.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安卓安全机制"><a href="#安卓安全机制" class="headerlink" title="安卓安全机制"></a>安卓安全机制</h1><h2 id="1-权限与隔离"><a href="#1-权限与隔离" class="headerlink" title="1.权限与隔离"></a>1.权限与隔离</h2><h3 id="1-1-linux中的用户-uid-，组-gid-，进程-pid"><a href="#1-1-linux中的用户-uid-，组-gid-，进程-pid" class="headerlink" title="1.1 linux中的用户(uid)，组(gid)，进程(pid)"></a>1.1 linux中的用户(uid)，组(gid)，进程(pid)</h3><p>​        在linux中，用户分为三种，普通用户，root用户，系统用户。每个uid会对应一个用户。普通用户一般只能在home目录，临时目录，以及其他授权目录下操作，以及只能操作属于该用户的文件。一般普通用户的uid大于500。root用户的id是0，是linux中的超级用户可以修改删除任意文件。系统用户是指系统运行时必须有的用户，比如运行网站服务，就需要系统用户apache来运行httpd进程，同理需要mysql用户运行mysqld进程。系统用户编号通常是1-499。</p><p>​        组id则是用户id的归属，每个用户至少属于一个组。</p><h3 id="1-2-linux进程的用户管理"><a href="#1-2-linux进程的用户管理" class="headerlink" title="1.2 linux进程的用户管理"></a>1.2 linux进程的用户管理</h3><p>​    每个进程拥有Real user ID即真实的用户，组(uid,gid)。Effective user ID即有效用户，有效组(euid,egid)。Saved set-user-ID保存的设置用户、组（suid、sgid）</p><p>​    1.真实用户/组好理解，就是进程的拥有者。</p><p>​    2.有效用户/有效组是什么作用呢: 方便资源访问，进程的权限实际上来自于有效用户的权限，比如su程序的权限，su 程序的所有者是 root，并且它被设置了 set-user-id 标志。这个标志意味着任何普通用户运行su程序时，有效用户就是该程序的所有者。根据有效用户的含义，任何运行 su 程序的普通用户都能访问 /etc/passwd 文件。有效用户为 root 进程称为特权进程（privileged processes）。EGID 的含义与 EUID 类似：给运行目标程序的组用户提供有效组的权限。</p><p>​    内核利用这些 ID 决定进程对共享资源拥有怎样的访问权，比如：消息队列、共享内存和信号量。尽管大多数的 UNIX 系统使用这些 ID 决定文件的访问权，但 Linux 使用的是独有的 <em>filesystem ID</em>。</p><p>​    3.Saved set-user-ID：这两个 ID 在 set-user-ID 与 set-group-ID 程序执行后，保存相应的 effective ID。因此，<strong>一个 <em>set-user-ID</em> 程序的 <em>effective user ID</em> 可以在 <em>real user ID</em> 与 <em>saved set-user-ID</em> 之间来回切换，从而可以恢复 / 抛弃特权</strong>。</p><ol start="4"><li><em>Filesystem user ID / Filesystem group ID</em>：这些 ID 用于决定进程对文件与其他共享资源的访问权。进程无论何时更改 <em>effective user/group ID</em>，内核也同时更改 <em>filesystem user/group ID</em>。</li></ol><h3 id="1-3-android系统中的uid-gid-gids与pid"><a href="#1-3-android系统中的uid-gid-gids与pid" class="headerlink" title="1.3 android系统中的uid,gid,gids与pid"></a>1.3 android系统中的uid,gid,gids与pid</h3><p>​    在android上，一个用户uid标志着一个应用程序，应用程序在安装时被分配uid。对于普通应用程序，gid和uid相同。gids:  个GIDS相当于一个权限的集合，一个UID可以关联GIDS，表明该UID拥有多种权限。gids在应用安装时生成。<br>     一个进程就是host应用程序的沙箱，里面一般有一个UID和多个GIDS，每个进程只能访问UID的权限范围内的文件和GIDs所允许访问的接口，构成了Android最基本的安全基础。</p><p>​    Android 使用沙箱的概念来实现应用程序之间的分离和权限，以允许或拒绝一个应用程序访问设备的资源，比如说文件和目录、网络、传感器和 API。为此，Android 使用一些 Linux 实用工具，来实现应用程序被允许执行的操作。</p><h2 id="2-Android-Permission权限控制机制"><a href="#2-Android-Permission权限控制机制" class="headerlink" title="2. Android Permission权限控制机制"></a>2. Android Permission权限控制机制</h2><h3 id="2-1-权限基本信息"><a href="#2-1-权限基本信息" class="headerlink" title="2.1 权限基本信息"></a>2.1 权限基本信息</h3><p>​    一个权限主要包含三个方面的信息: 权限的名称、属于的权限组、保护级别。一个权限组是指把权限按照功能分成不同的集合，每个权限组包含N个具体权限。例如CONTACTS组中，包含WRITE_CONTACTS,GET_ACCOUNTS,READ_CONTACTS等和联系人相关的权限。可以通过pm list 命令去获取相应的permission信息。也可以通过查看/data/sytem/packages.xml文件来获取。</p><h3 id="2-2-权限等级"><a href="#2-2-权限等级" class="headerlink" title="2.2 权限等级"></a>2.2 权限等级</h3><p>​    android权限分为normal,dangerous,signature,signatureOrSystem,system,development等，不同级别对应了不同的验证方式。normal只要申请了即可，dangerous的权限需要在安装时用户确认，signature则需要签名才赋予权限，signatureOrSystem需要签名或者系统级应用(放置在/system/app目录下)才能赋予权限，system系统级应用(放置在/system/app目录下)才能赋予权限，系统权限的描述在frameworks/base/core/res/AndroidManifest.xml当中。 </p><p>​    android 6.0（api level 23)之后进行了一次权限大升级，其中出现了一个新的protectionLevel叫做”signature|privileged”，signatureOrSystem变成了deprecated。在这之后，系统分成了system app和priviledged app，其中/system/app目录下的应用只有system权限，而/system/priv-app/目录下的应用才有privileged app 权限。而”signature|privileged”的权限等同于android6.0之前的signatureOrSystem。大于等于此时的system权限。</p><p>​    Package 的权限信息主要 通过在 AndroidManifest.xml 中通过一些标签来指定。如 <permission> 标签， <permission-group> 标签 <permission-tree> 等标签。如果 package 需要申请使用某个权限，那么需要使用 <use-permission> 标签来指定。</use-permission></permission-tree></permission-group></permission></p><h3 id="2-4-android提供的permission接口"><a href="#2-4-android提供的permission接口" class="headerlink" title="2.4 android提供的permission接口"></a>2.4 android提供的permission接口</h3><p>​    android提供了一组api供app检查某个调用，主要用来检查某个调用（或者是其它 package 或者是自己）是否拥有访问某个 permission 的权限。参数中 pid 和 uid 可以指定，如果没有指定，那么 framework 会通过 Binder 来获取调用者的 uid 和 pid 信息，加以填充。返回值为 PackageManager.PERMISSION_GRANTED 或者 PackageManager.PERMISSION_DENIED </p><p>​    checkPermission判断流程：    </p><p>​    1） 如果 uid 为 0 ，说明是 root 权限的进程，对权限不作控制。</p><p>​    2） 如果 uid 为 system server 进程的 uid ，说明是 system server ，对权限不作控制。</p><p>​    3） 如果是ActivityManager，对权限不做控制</p><p>​    4） 首先通过调用 getUserIdLP，根据uid去获取权限列表，判断是否有相应权限</p><p>​    5） 如果没找到，则会去PackageManagerService.mSystemPermissions 中找。这些信息是启动时，从 /system/etc/permissions/platform.xml 中读取的。这里记录了一些系统级的应用(如日历，浏览器，短信等)的 uid 对应的 permission 。</p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><p><a href="https://vvl.me/2018/09/linux-credentials/" target="_blank" rel="noopener">https://vvl.me/2018/09/linux-credentials/</a></p><p><a href="https://blog.csdn.net/vshuang/article/details/43639211" target="_blank" rel="noopener">https://blog.csdn.net/vshuang/article/details/43639211</a></p><p><a href="https://blog.csdn.net/vshuang/article/details/44001661?spm=a2c6h.12873639.article-detail.5.7adf49b0DMuNpO" target="_blank" rel="noopener">https://blog.csdn.net/vshuang/article/details/44001661?spm=a2c6h.12873639.article-detail.5.7adf49b0DMuNpO</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安卓安全机制&quot;&gt;&lt;a href=&quot;#安卓安全机制&quot; class=&quot;headerlink&quot; title=&quot;安卓安全机制&quot;&gt;&lt;/a&gt;安卓安全机制&lt;/h1&gt;&lt;h2 id=&quot;1-权限与隔离&quot;&gt;&lt;a href=&quot;#1-权限与隔离&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="android" scheme="http://pidanxu.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android study 7 https</title>
    <link href="http://pidanxu.github.io/2022/06/29/android-study-7-https/"/>
    <id>http://pidanxu.github.io/2022/06/29/android-study-7-https/</id>
    <published>2022-06-29T14:40:37.000Z</published>
    <updated>2022-06-30T16:29:19.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="https认证"><a href="#https认证" class="headerlink" title="https认证"></a>https认证</h1><h2 id="1-SSL身份验证的工作原理"><a href="#1-SSL身份验证的工作原理" class="headerlink" title="1.SSL身份验证的工作原理"></a>1.SSL身份验证的工作原理</h2><p>​    1.网站的所有者需要为网站域名购买SSL证书。然后CA进行验证，验证成功后，为该域名颁发SSL证书</p><p>​    2.网站所有者将CA机构颁发的SSL证书公钥和私钥都安装到网站服务器上</p><p>​    3.客户端提交HTTPS请求，进行SSL<strong>握手</strong></p><p>​    4.当SSL握手结束后，浏览器生成会话密钥，并使用SSL证书中的公钥对会话密钥进行加密</p><p>​    5.服务器接收到后用私钥进行解密</p><p>​    6.浏览器与服务器用这个会话密钥解密传输过程中的数据</p><h2 id="2-中间人攻击"><a href="#2-中间人攻击" class="headerlink" title="2.中间人攻击"></a>2.中间人攻击</h2><p>​    中间人攻击流程如下：</p><p>​    1.客户端发起https请求，开始三次握手，并且发送SSL版本及生成的随机数random-c</p><ol start="2"><li>中间人拦截客户端发送的内容，自己记录random-c并且发送客户端信息给服务器。</li><li>服务器收到信息，生成随机数random-s，将随机数random-s与SSL证书，公钥发送给客户端。</li><li>中间人拦截信息，将服务器发送的信息记录下来，将自己的SSL证书和公钥发送给客户端</li><li>客户端收到中间人发来的SSL证书，公钥，进行验证。客户端到自己信任的CA证书机构列表进行对比。此时攻击者可以自己花钱买一份受认证的证书，也可以设法让受害者下载证书到本地并且信任。这样的话客户端就会通过证书验证，然后发送自己支持的加密方式给服务器</li><li>中间人获取支持的加密方式，转发给服务器</li><li>服务器收到加密方式列表，选择合适的对称加密给客户端，中间人拦截下来记录后转发</li><li>客户端收到加密方式，生成随机数pre-master，和之前的随机数random-s,random-c一起组成对称加密密钥，然后将pre-master使用之前收到的公钥加密，发送给服务器</li><li>中间人截获信息，用自己的私钥解密后，用服务器的公钥加密传送给服务器</li><li>这个时候，中间人自己已经有了对称加密密钥。就已经可以掌握两方的通信内容了。</li></ol><h2 id="3-SSL-Pinning"><a href="#3-SSL-Pinning" class="headerlink" title="3. SSL Pinning"></a>3. SSL Pinning</h2><p>​    如何防范中间人攻击呢? 可以采用SSL Pinning。也就是将服务器提供的证书内置到app中，当客户端发起请求时，可以通过对比内置的证书和服务器证书内容，以验证服务器证书。</p><h3 id="3-1-证书锁定和公钥锁定"><a href="#3-1-证书锁定和公钥锁定" class="headerlink" title="3.1 证书锁定和公钥锁定"></a>3.1 证书锁定和公钥锁定</h3><p>​    <strong>证书锁定</strong></p><p>​    将APP代码内置为仅接受指定域名的证书，不接受系统或者浏览器内置的CA证书。通过这种方式，即可保障APP与服务端通信的唯一性和安全性。但是证书过期了的话app内置的也需要相应更换。</p><p>​    <strong>公钥锁定</strong></p><p>​    提取服务器证书的公钥并内置到移动端APP中，通过公钥值对比来保证连接的安全性。这样证书更新了也不用换密钥对，可以解决证书过期需要更新的问题。</p><h3 id="3-2-绕过ssl-pinning"><a href="#3-2-绕过ssl-pinning" class="headerlink" title="3.2 绕过ssl pinning"></a>3.2 绕过ssl pinning</h3><p>​    可以使用Frida把自己创建的TrustManager作为参数塞给SSLcontext.init，或者把相关的校验api的返回值给hook掉，就能干掉ssl pinning校验了。如果是双向认证的话，还需要提取app中内置的证书。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;https认证&quot;&gt;&lt;a href=&quot;#https认证&quot; class=&quot;headerlink&quot; title=&quot;https认证&quot;&gt;&lt;/a&gt;https认证&lt;/h1&gt;&lt;h2 id=&quot;1-SSL身份验证的工作原理&quot;&gt;&lt;a href=&quot;#1-SSL身份验证的工作原理&quot; cla</summary>
      
    
    
    
    
    <category term="android" scheme="http://pidanxu.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android study 6</title>
    <link href="http://pidanxu.github.io/2022/06/23/android-study-6/"/>
    <id>http://pidanxu.github.io/2022/06/23/android-study-6/</id>
    <published>2022-06-23T04:08:59.000Z</published>
    <updated>2022-06-28T15:16:17.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安卓的加固与脱壳"><a href="#安卓的加固与脱壳" class="headerlink" title="安卓的加固与脱壳"></a>安卓的加固与脱壳</h1><h2 id="1-Dex壳"><a href="#1-Dex壳" class="headerlink" title="1. Dex壳"></a>1. Dex壳</h2><p>​     Dex壳可以分为三种类型:</p><p>​    1. 整体加壳。将目标Apk里的整个dex文件内容都进行加密/压缩。运行的时候壳dex负责将App的dex解密还原并加载到虚拟机中。加载的方式可以采用文件加载或者内存加载。如果发现找不到组件类的实现，那就可以判断是加了整体壳。</p><ol start="2"><li><p>函数粒度加壳。把dex中的某些方法抽空，使用nop指令填充，壳会在合适的时机把方法内容还原，这有点像SMC。</p></li><li><p>指令粒度加壳。比如VMP，用自己实现的解释器来执行加壳后的smali指令。以及dex2C, 可以把java的方法转换为native方法。</p></li></ol><h3 id="1-1-整体壳的工作流程"><a href="#1-1-整体壳的工作流程" class="headerlink" title="1.1 整体壳的工作流程"></a>1.1 整体壳的工作流程</h3><p>​        整体加壳需要完成三个任务。1.把原始的dex文件加密/压缩。2.获得控制权并且访问原始dex的加密后数据，将其解密。3. 动态加载解密后的dex文件，并且让java虚拟机可以识别到dex文件中的四大组件。</p><p>​        <strong>任务1</strong></p><p>​        壳将原始的dex文件加密添加到壳dex文件的末尾，并且更新壳dex文件的checksum,signature和file_size反映出这些变化，因为在dex文件的头部信息中会保留这些值来检查dex文件格式的正确性。修改了这三个值以后，壳dex文件的末尾就可以添加一些和dex格式定义中无关的信息，比如原始dex文件的个数，大小以及加密以后原始dex文件的内容。然后将壳dex替换掉原始的dex文件对Apk进行重打包即可。</p><p>​        <strong>任务2</strong></p><p>​        壳会把自己的Application类替换掉原来的Application类，因此壳的Application类的<code>onCreate()</code>和<code>attachBaseContext()</code>会在App进程启动的时候率先执行拿到控制权。而访问被隐藏加密的dex可以通过<code>getApplicationInfo().sourceDir</code>来获取apk的路径，解压apk得到壳dex文件从而解密出壳dex文件里边附带的原始dex文件。</p><p>​        <strong>任务3</strong></p><p>​        壳会使用类加载器动态加载解密后的dex文件，为了让组件的生命周期函数也正常运行，还要对类加载器进行修正。</p><p>​        类加载器可以在运行的时候加载在编译时未知的类,而Android里边的<code>BaseDexClassLoader</code>可以实现在运行的时候加载在编译时未知的dex文件，经过此加载器的加载，ART虚拟机内存中会形成相应的数据结构，对应的dex文件也会由mmap映射到虚拟内存当中，通过此加载器的<code>loadClass(String className, boolean resolve)</code>方法就可以得到类的Class对象，从而可以使用该类。</p><p>​        PatchClassLoader可以加载开发者自己编写的类，也就是classpath下的类。他有一个兄弟类叫DexClassLoader。他们都是继承自<code>BaseDexClassLoader</code>。壳会使用DexClassLoader来动态加载解密后的dex文件。<strong>PathClassLoader</strong>是Android默认使用的类加载器，一个APK的Activity等类是在其中加载。DexClassLoader可以加载任意目录下的dex/jar/apk/zip文件，比PathClassLoader更加灵活，是实现热更新、热修复、dex加壳的重点。</p><p>​        对类加载器的修正：加载完原始的dex以后还需要对<code>ClassLoader</code>进行修正，否则加载组件类运行的时候会报<code>ClassNotFoundException</code>，为什么会报这种错误呢? 这就涉及到了组件类的创建过程，比如对于Activity来说，应用程序的Activity对象是在ActivityThread类的<code>performLaunchActivity()</code>方法中通过调用<code>mInstrumentation.newActivity()</code>创建出来的。newActivity是通过<code>ClassLoader</code>先加载Activity类，再通过<code>newInstance()</code>来实例化类对象。<br>​     由于组件相关的Activity实际上是由PathClassLoader进行加载的，虽然可以通过反射拿到需要动态加载的Activity,但是却造成ActivityManager在管理上无法找到我们要加载的Activity,因为是先加载AndroidManifest才到onCreate的！<br>     为了解决上面的问题，可以有两种解决方案（核心目的都是使得组件类的加载交由DexClassLoader完成）:</p><p>​    1.替换系统的组件类加载器为DexClassLoader，同时设置DexClassLoader的parent为系统组件类加载器。</p><p>​    2. 打破原有的双亲关系，在系统组件类加载器和BootClassLoader的中间插入DexClassLoader即可；</p><h3 id="1-2-指令抽取型壳的工作流程"><a href="#1-2-指令抽取型壳的工作流程" class="headerlink" title="1.2 指令抽取型壳的工作流程"></a>1.2 指令抽取型壳的工作流程</h3><h4 id="1-2-1-android免root权限hook系统函数，从而修改程序运行时的内存指令"><a href="#1-2-1-android免root权限hook系统函数，从而修改程序运行时的内存指令" class="headerlink" title="1.2.1 android免root权限hook系统函数，从而修改程序运行时的内存指令"></a>1.2.1 android免root权限hook系统函数，从而修改程序运行时的内存指令</h4><p>​    大概流程如下：</p><pre><code>1. 每个方法要运行，首先会将类加载到内存中，那么就需要调用安卓系统中的dexFindClass函数，这个函数的返回值是一个DexClassDef结构体信息, 通过里面的成员class_data找下去会有一个code_item成员，存了方法的指令信息。 2. 把相关的内存区域改为可写，修改指令为自定义指令，覆盖原指令即可。</code></pre><h4 id="1-2-2-抽取型壳工作原理"><a href="#1-2-2-抽取型壳工作原理" class="headerlink" title="1.2.2 抽取型壳工作原理"></a>1.2.2 抽取型壳工作原理</h4><p>​    1.首先通过解析dex文件，将其指定方法内容指令置空。然后重新计算checksum和signature信息写回到头部。</p><p>​    2.参考1.2.1篡改内存指令即可。</p><h4 id="1-2-3-art中存在的问题"><a href="#1-2-3-art中存在的问题" class="headerlink" title="1.2.3 art中存在的问题"></a>1.2.3 art中存在的问题</h4><p>​    art由于存在quick code，所以如果还原指令的时机不对，art就执行quick code去了，还原的指令自然不生效。这种情况下要么禁用dex2oat，要么在dex2oat之前就还原dex文件，但是这样的话只要在dex2oat的流程中进行脱壳就能dump下来完整的dex文件了。</p><h3 id="1-3-vmp-java2c"><a href="#1-3-vmp-java2c" class="headerlink" title="1.3 vmp/java2c"></a>1.3 vmp/java2c</h3><p>​    其实就是自定义指令集，然后自己写解释器去解释执行。或者也可以把dex里的指令转成c,c++，然后去执行。</p><h2 id="2-脱壳"><a href="#2-脱壳" class="headerlink" title="2. 脱壳"></a>2. 脱壳</h2><p>​        脱壳的总体思路就是：在某个时间，内存里是会有完整的解密后的dex文件。脱壳就是把这个解密后的dex给dump下来。</p><p>​        <strong>art:DexFile</strong></p><p>​        这是art虚拟机里一个关键的数据结构，它有两个成员变量，分别代表着dex文件加载到内存后的大小以及起始地址。类加载器是会用到这个数据结构的。即使是art的quick code模式(被编译到机器码)也会有完整dex文件存在。</p><h3 id="2-1-修改源码脱壳"><a href="#2-1-修改源码脱壳" class="headerlink" title="2.1 修改源码脱壳"></a>2.1 修改源码脱壳</h3><p>​        找到libart.so文件中所有导出函数中带有<code>art::DexFile</code>参数或者返回值的函数，那么这就是一个可以脱壳的点。在这些函数里把dex写入文件即可。</p><h3 id="2-2-Frida脱壳"><a href="#2-2-Frida脱壳" class="headerlink" title="2.2 Frida脱壳"></a>2.2 Frida脱壳</h3><p>​        网上看到一篇文章用Frida进行内存搜索，从内存中把已经解密的dex给dump下来。通过在内存里搜索dex文件特征。或者通过DexFile.java类的mCookie变量来获取。对于通过使用<code>BaseDexClassLoader</code>来加载的程序来说，<code>DexFile.java</code>类的<code>mCookie</code>变量在native层的表现其实是一个jlong类型的指针的数组，数组的个数为此<code>ClassLoader</code>加载的dex文件个数 + 1,第一个元素类型为<code>OatFile*</code>,剩余的元素为对应的<code>art::DexFile*</code>，因此可以通过获取<code>mCookie</code>变量来得到<code>art::DexFile*</code>列表，并且通过<code>art::DexFile</code>的begin和size来dump。利用 Java.enumerateClassLoadersSync()来枚举所有类加载器，从中进行判断，把BaseDexClassLoader加载的Dex都dump下来。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://www.juziss.cn/2020/09/22/app%E7%9A%84%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/" target="_blank" rel="noopener">http://www.juziss.cn/2020/09/22/app%E7%9A%84%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/</a></p><p><a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1116812&amp;extra=page%3D1%26filter%3Dtypeid%26typeid%3D343" target="_blank" rel="noopener">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1116812&amp;extra=page%3D1%26filter%3Dtypeid%26typeid%3D343</a></p><p><a href="https://www.anquanke.com/post/id/195869" target="_blank" rel="noopener">https://www.anquanke.com/post/id/195869</a></p><p><a href="https://blog.csdn.net/m0_46204016/article/details/104579953" target="_blank" rel="noopener">https://blog.csdn.net/m0_46204016/article/details/104579953</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安卓的加固与脱壳&quot;&gt;&lt;a href=&quot;#安卓的加固与脱壳&quot; class=&quot;headerlink&quot; title=&quot;安卓的加固与脱壳&quot;&gt;&lt;/a&gt;安卓的加固与脱壳&lt;/h1&gt;&lt;h2 id=&quot;1-Dex壳&quot;&gt;&lt;a href=&quot;#1-Dex壳&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="android" scheme="http://pidanxu.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android-anti-debug</title>
    <link href="http://pidanxu.github.io/2022/06/20/android-anti-debug/"/>
    <id>http://pidanxu.github.io/2022/06/20/android-anti-debug/</id>
    <published>2022-06-20T05:20:09.000Z</published>
    <updated>2022-06-22T14:39:39.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安卓反调试"><a href="#安卓反调试" class="headerlink" title="安卓反调试"></a>安卓反调试</h1><h2 id="1-java层反调试"><a href="#1-java层反调试" class="headerlink" title="1. java层反调试"></a>1. java层反调试</h2><p>​    Android的android.os.Debug类提供了isDebuggerConnected()方法，用于检测是否有调试器挂载到程序上。首先会想到，能不能改了smali重新编译回去？问题在于app有签名校验，改了smali后不能再打开该app。所以一个比较好的方法是用frida进行hook。还看到有人思路是直接修改测试机的系统，把aosp的相关代码直接改为returen False。</p><h2 id="2-native层反调试"><a href="#2-native层反调试" class="headerlink" title="2. native层反调试"></a>2. native层反调试</h2><h3 id="2-1-调试端口检测"><a href="#2-1-调试端口检测" class="headerlink" title="2.1 调试端口检测"></a>2.1 调试端口检测</h3><p>​    android_server的默认监听的端口号是23946，所以可以通过检测这个端口号来起到一定的反调试作用。在Linux系统中，<code>/proc/net/tcp</code>文件会记录一些连接信息，在启动android_server以后，文件中会多出一条23946端口的记录。这样可以起到检测调试的作用，当然如果调试指定了其他监听端口，本方法就无法检测了。</p><h3 id="2-2-基于时间检测"><a href="#2-2-基于时间检测" class="headerlink" title="2.2 基于时间检测"></a>2.2 基于时间检测</h3><p>​    利用计时api,判断某段代码用时是否异常，如果某段代码用时明显长于正常值，则很可能是在调试当中。</p><h3 id="2-3-基于文件检测"><a href="#2-3-基于文件检测" class="headerlink" title="2.3 基于文件检测"></a>2.3 基于文件检测</h3><p>​    可以去读取一些/proc目录下的文件。</p><p>​    1. /proc/pid/status文件，在未调试的情况下，TracerPid这一项是0，调试状态下是调试进程的PID。/proc/pid/stat文件，在调试状态下，会有t字符的标志出现。/proc/pid/wchan文件，在调试状态下，里面的内容是ptrace_stop。</p><h3 id="2-4-基于文件格式反调试"><a href="#2-4-基于文件格式反调试" class="headerlink" title="2.4 基于文件格式反调试"></a>2.4 基于文件格式反调试</h3><ol><li><p>比如文件名是假的，需要用别的文件格式去解析。</p><ol start="2"><li>文件数据被修改，可以正常运行但是无法被IDA等工具解析。</li></ol></li></ol><p>比如elf的文件头在系统运行时解析和工具解析是不一样的，这时候可以精心构造一个文件头，让readelf/IDA等工具解析失败。</p><h3 id="2-5-ptrace"><a href="#2-5-ptrace" class="headerlink" title="2.5 ptrace"></a>2.5 ptrace</h3><p>​    因为Linux下每个进程同时只能被一个进程调试，linux 系统gdb等调试器，都是通过ptrace系统调用实现。所以app可以先ptrace自己，防止调试器附加。解决办法就是找到ptrace代码手工patch掉。或者可以在LD_PRELOAD里设置一个自定义的so，自己在so里实现一个fake_ptrace，相当于把ptrace给hook掉。</p><p>​    以及看到网上有思路可以用ptrace附加zygote,去拦截zygote的fork子进程，从而定位到目标应用pid。然后拦截目标pid的系统调用，把ptrace_traceme这种相关参数改了，让ptrace失败。</p><h3 id="2-6-断点扫描"><a href="#2-6-断点扫描" class="headerlink" title="2.6 断点扫描"></a>2.6 断点扫描</h3><p>​    1.调试器的原理是向断点地址插入breakpoint的汇编指令，把原来的指令暂存到别处。那么就可以扫描本so内存中有没有breakpoint指令就好了。</p><p>​    2.另一方面，breakpoint指令会使被调试进程发出信号SIGTRAP，调试器会截获linux系统给被调试进程的信号。由调试者来选择是否传递信号。但是SIGTRAP是个例外，因为通常的目标程序中不会出现breakpoint，因为这会使得程序自己奔溃。因此，当调试器遇到SIGTRAP信号时会认为是自己下的断点发出的。这样一来当调试器给这个breakpoint命令插入断点breakpoint后，备份的命令也是breakpoint，这样当继续执行时，调试器将备份指令恢复并执行，结果误以为备份后这个位置发出的SIGTRAP又是自己下的断点造成的，这样一来就会使得调试器的处理逻辑出现错误，不同的调试器会导致各种不同的问题。开发者可以在自己的signal handler函数里再把breakpoint指令替换为相关函数。</p><h3 id="2-7-调试器错误理解"><a href="#2-7-调试器错误理解" class="headerlink" title="2.7 调试器错误理解"></a>2.7 调试器错误理解</h3><p>​    Arm架构的CPU却不仅仅只是运行Arm指令集，还会运行Thumb指令集，并且目前Android Studio已经将Thumb-2模式设定为默认NDK编译指令集，比Arm指令集还要优先。这是为什么？因为Thumb-2模式是Thumb16和Thumb32指令的混合执行，有更高的效率和代码密度，对于APP的运行效率和空间占用都有着更好的表现。</p><p>​    但是这对于调试器来说并不是好事。Thumb16和Thumb32在opcode上没有冲突，只要一条条按照顺序去反汇编，就可以得到正确的Thumb指令。但是Arm指令集和Thumb指令集是会有冲突的，一条Thumb32指令是可以被理解为作用意义完全不同的另一条Arm指令的，甚至2条Thumb16指令可以被调试器误解为一条合法的Arm指令。</p><p>​    而这两个模式的切换涉及跳转时候的地址数值，这个值可能是动态产生的，因此对编译器来说难以判断跳转后的代码是该理解为Thumb还是Arm。</p><h3 id="2-8-多进程-线程"><a href="#2-8-多进程-线程" class="headerlink" title="2.8 多进程/线程"></a>2.8 多进程/线程</h3><p>​    这里意思是开一个守护线程，用来检测父线程是否被调试。算是反调的一种实现方式吧，原理还是以上检测原理。</p><h3 id="2-9-进程名"><a href="#2-9-进程名" class="headerlink" title="2.9 进程名"></a>2.9 进程名</h3><p>​    遍历进程，看有没有android-server之类的进程，来判断是否有调试器</p><h3 id="2-10-利用调试器截获信号进行反调试"><a href="#2-10-利用调试器截获信号进行反调试" class="headerlink" title="2.10 利用调试器截获信号进行反调试"></a>2.10 利用调试器截获信号进行反调试</h3><p>​    调试器会截获系统给进程的信号，然后选择是否传递给进程。那其实可执行文件里就可以自己将一些流程放在信号处理函数中，从而达到检测调试目的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安卓反调试&quot;&gt;&lt;a href=&quot;#安卓反调试&quot; class=&quot;headerlink&quot; title=&quot;安卓反调试&quot;&gt;&lt;/a&gt;安卓反调试&lt;/h1&gt;&lt;h2 id=&quot;1-java层反调试&quot;&gt;&lt;a href=&quot;#1-java层反调试&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="android" scheme="http://pidanxu.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android study 5-java</title>
    <link href="http://pidanxu.github.io/2022/06/16/android-study-5-java/"/>
    <id>http://pidanxu.github.io/2022/06/16/android-study-5-java/</id>
    <published>2022-06-16T03:03:06.000Z</published>
    <updated>2022-06-20T05:08:50.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java反射机制"><a href="#java反射机制" class="headerlink" title="java反射机制"></a>java反射机制</h1><h2 id="1-什么是java反射"><a href="#1-什么是java反射" class="headerlink" title="1.什么是java反射"></a>1.什么是java反射</h2><p>​    java反射是指在运行状态中，对于任意类，都可以得到这个类的属性，方法信息，以及得到这个类的对象。对于任意对象，都可以调用它的方法，以及访问它的属性。这种动态获取信息，动态调用对象方法的功能叫做java的反射机制。</p><h3 id="1-1-java反射使用场景"><a href="#1-1-java反射使用场景" class="headerlink" title="1.1 java反射使用场景"></a>1.1 java反射使用场景</h3><p>​    比如不知道类或者对象的具体信息，比如类的名称放在某个文件中，需要运行时读取文件以动态获取类的信息。或者注入后想要覆写函数地址完成hook，也可以通过java反射来完成。</p><h3 id="1-2-基础知识"><a href="#1-2-基础知识" class="headerlink" title="1.2 基础知识"></a>1.2 基础知识</h3><p>​    在JVM中，会为每个加载的类维护一个类对象，然后根据类对象来创造实例对象或者提供静态变量。</p><p>​    class对象的获取：</p><pre><code>1. 通过对象.getClass()2. 通过类.class字面量3. 通过class类的forName方法4. 通过类加载器的loadClass</code></pre><p>那么如何对class对象进行操作呢？先获取到类型的Class对象，通过Class对象的newInstance方法可以得到类的实例。通过Class对象可以获取到Constructor对象，进一步可以使用Constructor对象来得到类的实例。通过Class对象可以获取到Method对象，通过Method的invoke方法可以调用一些方法。通过Class对象可以获取到Field对象，我们可以对这个实例的一些字段进行赋值取值操作。流程如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">actionClass = Class.forName（“ MyClass”）;</span><br><span class="line">action = actionClass.newInstance（）;</span><br><span class="line">method = actionClass.getMethod（“ myMethod”，<span class="keyword">null</span>）;</span><br><span class="line">method.invoke（action，<span class="keyword">null</span>）;</span><br></pre></td></tr></table></figure><h2 id="2-动态代理与静态代理"><a href="#2-动态代理与静态代理" class="headerlink" title="2.动态代理与静态代理"></a>2.动态代理与静态代理</h2><p>​    代理本身不实现具体服务，只是利用委托类完成服务，在此过程中对输入输出做一些处理。</p><h3 id="2-1-静态代理"><a href="#2-1-静态代理" class="headerlink" title="2.1 静态代理"></a>2.1 静态代理</h3><p>​    静态代理中，代理类和被代理类会实现同样的接口。代理类同时会持有有被代理类的对象。可以通过调用代理类的方法以调用被代理类的对应方法，相当于可以增加一些前置准备工作。比如给该方法添加一个计时的操作。</p><h3 id="2-2-动态代理"><a href="#2-2-动态代理" class="headerlink" title="2.2 动态代理"></a>2.2 动态代理</h3><p>​    动态代理类需要实现InvocationHandler接口以执行动态代理，需要重写invoke函数以实现动态代理。里面是具体的代理服务。动态代理具体步骤如下:</p><p>​    1.通过实现InvocationHandler接口创建自己的调用处理器</p><pre><code>2. 通过为Proxy指定ClassLoader对象和一组interfaces来创建动态代理类3. 通过反射机制获得动态代理类的构造函数，唯一参数是调用处理器的接口类型4. 通过构造函数创建动态代理类型实例，构造时调用器类型作为参数传入(具体来说，是jdk根据传入的参数信息，在内存中动态创建.class文件，然后通过newInstance创建动态代理类的实例)</code></pre><p>​    Java动态代理实际上通过反射技术，把代理对象和被代理对象(真实对象)的代理关系建立延迟到程序运行之后，动态创建新的代理类去完成对真实对象的代理操作(可以改变原来真实对象的方法行为)，这一点成为了当前主流的AOP框架和延迟加载功能的基础。</p><h2 id="3-双亲委派"><a href="#3-双亲委派" class="headerlink" title="3.双亲委派"></a>3.双亲委派</h2><h3 id="3-1-类的初始化"><a href="#3-1-类的初始化" class="headerlink" title="3.1 类的初始化"></a>3.1 类的初始化</h3><p>​    大多数情况下，类加载后直接就初始化了。以下三种情况是，类加载后，会延迟初始化。</p><p>​    1.通过子类调用父类的静态成员时，只需要完成父类的初始化，子类初始化被延迟了。</p><p>​    2.使用某个类的静态常量时，可以延迟类的初始化。</p><p>​    3.使用某个类声明并创建数组时，如果还未真正创建该类的对象时，可以延迟类的初始化</p><p>​    以上三种以外的，都会直接对类进行初始化：</p><p>​    1.new对象</p><p>​    2.调用某个类的静态变量</p><p>​    3.通过反射的API调用该类成员等</p><p>​    4.main方法所在的类，一定先初始化完成，再执行main方法的。</p><p>​    5.当子类初始化时，如果父类还未初始化，会先初始化父类。</p><h3 id="3-2-类加载器"><a href="#3-2-类加载器" class="headerlink" title="3.2 类加载器"></a>3.2 类加载器</h3><p>​    类加载器的类型是java.lang.classloder，是负责类的初始化工作。</p><p>​    1.引导类加载器(Bootstrap ClassLoader),由C语言编写，负责加载最核心的类库。</p><pre><code>2. 扩展类加载器(Extension ClassLoader)，负责加载扩展库。JRE的lib中的ext目录下的扩展库 3. 应用程序类加载器(Application ClassLoader)，负责加载用户自定义的类型，在classpath下的类 4. 自定义类加载器。加载classpath以外的类，或者需要在加载时做一些操作如解密，这时候需要使用自定义类加载器。</code></pre><h3 id="3-3-双亲委托模式"><a href="#3-3-双亲委托模式" class="headerlink" title="3.3 双亲委托模式"></a>3.3 双亲委托模式</h3><p>​    应用程序类加载器把扩展类加载器视为双亲，扩展类加载器把引导类加载器 视为双亲。其原理是当JVM接到一个”类的加载任务时“，AppClassLoader先相应，它会在当前方法区找找看，如果加载过了，就不会重复加载。</p><p>​    如果发现这个类没有加载过，它会将加载类的任务再次提交给”parent“，此时就是引导类加载器，他也会先找一下是不是被加载过了。加载过了就不再重复加载了。</p><p>​    如果引导类加载器发现这个类没有加载过，它就把加载类的任务提交给自己的”parent“，此时就是JRE核心类库的rt.jar，如果自己负责的目录下有，就正常加载，返回Class对象即可。</p><p>​    如果引导类加载器在自己负责的目录下找不到这个类，就会把任务传给ExtClassLoader，ExtClassLoader接下来也在自己负责的目录下尝试加载，此处时JRE的lib中的ext目录下的扩展库，如果自己负责的目录下有，就正常加载，返回Class对象即可。</p><p>​    如果AppClassLoader在自己负责的目录下还找不到这个类，就报异常ClassNotFoundException异常。</p><p>​    如果在前面的加载过程中，加载失败会报NoClassDefFoundError，ClassFormatError等。</p><p>​    这样做的好处是安全，用户定义的类就不会覆盖到核心类库中的类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java反射机制&quot;&gt;&lt;a href=&quot;#java反射机制&quot; class=&quot;headerlink&quot; title=&quot;java反射机制&quot;&gt;&lt;/a&gt;java反射机制&lt;/h1&gt;&lt;h2 id=&quot;1-什么是java反射&quot;&gt;&lt;a href=&quot;#1-什么是java反射&quot; class</summary>
      
    
    
    
    
    <category term="android java" scheme="http://pidanxu.github.io/tags/android-java/"/>
    
  </entry>
  
  <entry>
    <title>android study 4</title>
    <link href="http://pidanxu.github.io/2022/05/27/android-study-4/"/>
    <id>http://pidanxu.github.io/2022/05/27/android-study-4/</id>
    <published>2022-05-27T12:50:46.000Z</published>
    <updated>2022-06-16T02:57:15.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-文件结构"><a href="#1-文件结构" class="headerlink" title="1.文件结构"></a>1.文件结构</h1><h2 id="1-1-ELF文件结构"><a href="#1-1-ELF文件结构" class="headerlink" title="1.1 ELF文件结构"></a>1.1 ELF文件结构</h2><h3 id="1-1-1-ELF文件结构概述"><a href="#1-1-1-ELF文件结构概述" class="headerlink" title="1.1.1 ELF文件结构概述"></a>1.1.1 ELF文件结构概述</h3><p>​    ELF文件由三部分组成，ELF文件头(位置固定，大小固定)，段头表，节头表。</p><p>​    ELF整体结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ELF Header -&gt; ELF 文件头的位置是固定的</span><br><span class="line">Program Header Table -&gt; ELF程序头描述的段的相关信息，用来告诉系统如何生成这个进程，如果是重定位文件(.o文件)可以没有这个表</span><br><span class="line">.shstrtab 该section包含了节的名称</span><br><span class="line">.bss 该section包含了在内存中程序的未初始化的数据，当程序运行开始时，系统将用0来初始化该区域。该section不占用文件空间，该section type = SHT_NOBITS。(bss存在的意义就是缩小二进制文件空间)</span><br><span class="line">.init </span><br><span class="line">.text 可执行区域(代码)</span><br><span class="line">.rodata 只读数据</span><br><span class="line">.data 和.data1 该section 包含了在内存中程序的初始化数据</span><br><span class="line">.debug 该section包含了符号调试信息</span><br><span class="line">.dynamic 该section包含了动态链接信息，该section属性将包含SHF_ALLOC比特位，而SHF_WRITE比特位是否为1取决于处理器</span><br><span class="line">.dynsym 该section包含了动态链接符号表</span><br><span class="line">.fini 该section 包含了用于终止进程可执行指令代码</span><br><span class="line">.symtab </span><br><span class="line">.hash 包含了符号hash表</span><br><span class="line">.line</span><br><span class="line">.strtab 字符串表</span><br><span class="line">.got 包含了全局偏移表</span><br><span class="line">.plt 程序链接表</span><br><span class="line">Section Header Table --&gt; ELF 节头表描述的是节区的信息 动态用段，静态是节区。对于可加载文件是可选的</span><br><span class="line">程序加载的时候只会加载LOAD 段</span><br></pre></td></tr></table></figure><p>​    Program Header Table中存储了segment的描述信息，segment是站在系统的角度对section的一种组织方式，对于操作系统而言，数据属性通常是读，写，执行，符合同一数据属性的 section 理论上就可以放到一起以节省加载时的内存，所以一个segment 中可以包含连续的多个 section。</p><p>​    而 section header 和 program header 都是对于 elf 文件中 sections 的描述，只是采用了不同的方式，elf 文件中的 sections 按照 segment 的组成形式进行排列，这样就不需要为每个 segment 重新生成一份针对 segment 的 sections 的组合.</p><h3 id="1-2-2-链接视图与执行视图"><a href="#1-2-2-链接视图与执行视图" class="headerlink" title="1.2.2 链接视图与执行视图"></a>1.2.2 链接视图与执行视图</h3><p>​    静态链接器会以链接视图解析ELF文件，编译时生成的.o文件以及链接后的.so文件均可通过链接视图进行解析，链接视图是没有段表的，如.o文件不会有段表。执行视图则是在程序被装载运行时用到的视图。链接视图以section为单位，执行视图以segment为单位。</p><h3 id="1-2-3-ELF文件头"><a href="#1-2-3-ELF文件头" class="headerlink" title="1.2.3 ELF文件头"></a>1.2.3 ELF文件头</h3><p>​    ELF文件头记录了ELF文件类型，结构，版本，程序入口地址等信息，并提供了节头表，程序头表在文件中的偏移位置。ELF文件头具体结构如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">   unsigned char e_ident[EI_NIDENT];</span><br><span class="line">   uint16_t      e_type;        /* ELF文件类型 */</span><br><span class="line">   uint16_t      e_machine;     /* 硬件平台 */</span><br><span class="line">   uint32_t      e_version;     /* ELF头部版本 */</span><br><span class="line">   ElfN_Addr     e_entry;       /* 程序执行的入口地址 */</span><br><span class="line">   ElfN_Off      e_phoff;       /* 程序执行的入口地址 */</span><br><span class="line">   ElfN_Off      e_shoff;       /* 节头表偏移量 */</span><br><span class="line">   uint32_t      e_flags;       /* 处理器特定标志  */</span><br><span class="line">   uint16_t      e_ehsize;      /* ELF头部长度 */</span><br><span class="line">   uint16_t      e_phentsize;   /* 程序头表中一个条目的长度 */</span><br><span class="line">   uint16_t      e_phnum;       /* 程序头表条目数目 */</span><br><span class="line">   uint16_t      e_shentsize;   /* 节头表中一个条目的长度  */ </span><br><span class="line">   uint16_t      e_shnum;       /* 节头表条目个数 */</span><br><span class="line">   uint16_t      e_shstrndx;    /* 节头表字符索引 */</span><br><span class="line">&#125; ElfN_Ehdr;</span><br></pre></td></tr></table></figure><h3 id="1-2-4-程序头表"><a href="#1-2-4-程序头表" class="headerlink" title="1.2.4 程序头表"></a>1.2.4 程序头表</h3><p>​    程序头表会记录ELF文件中所有段的信息，包括段的类型，段的偏移地址，段的虚拟地址，物理地址等信息。段类型则可以分为PT_LOAD(描述可装载的段，如代码段，数据段，这些可被装载进内存中)，PT_DYNAMIC(动态链接文件特有，包含了动态链接文件所需要的信息) ，PT_NOTE(保存了与特定供应商或者系统相关的附加信息)，PT_INTERP，PT_PHDR(程序头表本身位置和大小) </p><h3 id="1-2-5-节头部表"><a href="#1-2-5-节头部表" class="headerlink" title="1.2.5 节头部表"></a>1.2.5 节头部表</h3><p>​    节头表用于描述ELF文件各节区的位置和大小，主要用于链接与调试，节头对于程序的运行来说不是必须的。</p><h2 id="1-2-Dex文件结构"><a href="#1-2-Dex文件结构" class="headerlink" title="1.2 Dex文件结构"></a>1.2 Dex文件结构</h2><h3 id="1-2-1-Dex文件头"><a href="#1-2-1-Dex文件头" class="headerlink" title="1.2.1 Dex文件头"></a>1.2.1 Dex文件头</h3><p>​    dex文件头一般固定为0x70个字节大小，包含标志、版本号、校验码、sha-1 签名以及其他一些方法、类的数量和偏移地址等信息。如下图所示。</p><h3 id="1-2-2-字符串解析"><a href="#1-2-2-字符串解析" class="headerlink" title="1.2.2 字符串解析"></a>1.2.2 字符串解析</h3><p>​    在文件头0x38和0x3c存储了字符串信息，分别是字符串数量以及字符串索引区的偏移地址。在字符串索引区，四字节一组表示一个字符串在数据区的偏移地址。偏移地址里采用了MUTF-8编码，第一个字节表示字符串长度，最后一个字节00表示字符串结束</p><h3 id="1-2-3-类的类型解析"><a href="#1-2-3-类的类型解析" class="headerlink" title="1.2.3 类的类型解析"></a>1.2.3 类的类型解析</h3><p>​    类的偏移地址里存储了该类名在字符串数组中的索引值，4字节一组。</p><h3 id="1-2-4-方法原型的解析"><a href="#1-2-4-方法原型的解析" class="headerlink" title="1.2.4 方法原型的解析"></a>1.2.4 方法原型的解析</h3><p>​    Dex中的方法原型定义了一个方法的返回值类型和参数类型，例如一个方法返回值为void，参数类型为int，则方法原型表示为V(I)。一共12个字节，前四个字节是用到的字符串索引，后八个字节是返回值，参数用到的类的索引。</p><h3 id="1-2-5-字段解析"><a href="#1-2-5-字段解析" class="headerlink" title="1.2.5 字段解析"></a>1.2.5 字段解析</h3><p>​    在偏移地址处有8个字节，前两个字节是之前解析出类的索引，表示这个字段在该类中定义。3-4字节也是类的索引，表示该字段类型。最后四个字节是字符串列表的索引，用来表示字段名。</p><h3 id="1-2-6-方法定义解析"><a href="#1-2-6-方法定义解析" class="headerlink" title="1.2.6 方法定义解析"></a>1.2.6 方法定义解析</h3><p>​    在偏移地址处有8个字节，前两个字节是类解析的索引，用来表示该方法属于哪个类。3-4字节是方法原型的索引，最后四个字节是字符串索引用来表示方法名。</p><h3 id="1-2-7-类的解析"><a href="#1-2-7-类的解析" class="headerlink" title="1.2.7 类的解析"></a>1.2.7 类的解析</h3><p>​    class_def_item有32个字节，1-4字节是之前类类型解析的索引，也就是类名。5-8字节是access_flags，是该类的访问标志，表明这个类是public还是private。9-12字节是父类类型解析的索引，也就是父类名。13-16字节是接口信息的偏移地址。17-20字节是字符串索引，表明该类所在的java文件名。21-24字节是注释信息的偏移地址，25-28字节指向class_data_off，是类数据第二层结构的偏移地址，该结构中记录了该类的方法和字段。29-32字节在没有相关信息情况下为0，如果有信息会指向一个结构的偏移地址。</p><p>​    <strong>类的第二次层结构：class_data_item</strong>    </p><p>​    class_data_item中第一个uleb128编码，指明了该类中静态字段的数量。第二个uleb128编码，指明了该类中实例字段的数量。第三个uleb128编码指明了该类中直接方法的个数。第四个uleb128编码指明了该类中虚方法的个数。然后如果各字段/方法数量&gt;0，又会有指明相应字段/方法详细信息的结构。这里具体以方法信息为例，里面有3个uleb128编码，第一个是方法原型的索引，第二个是访问标志，第三个则是方法具体字节码的偏移地址。对应结构体是<strong>code_item</strong>，里面记录了smali代码。</p><p>​    <strong>类的第三层结构: code_item</strong></p><p>​    code_item中会记录该方法使用的寄存器数量，参数个数，try-catch数量，调试信息结构体偏移，指令列表等信息。指令列表里面就是一些opcode。</p><p>到这里，其实就可以根据以上信息对dex进行一个反编译为smali指令的工作了。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://cloud.tencent.com/developer/article/1663852" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1663852</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-文件结构&quot;&gt;&lt;a href=&quot;#1-文件结构&quot; class=&quot;headerlink&quot; title=&quot;1.文件结构&quot;&gt;&lt;/a&gt;1.文件结构&lt;/h1&gt;&lt;h2 id=&quot;1-1-ELF文件结构&quot;&gt;&lt;a href=&quot;#1-1-ELF文件结构&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="android" scheme="http://pidanxu.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android study 3</title>
    <link href="http://pidanxu.github.io/2022/05/22/android-study-3/"/>
    <id>http://pidanxu.github.io/2022/05/22/android-study-3/</id>
    <published>2022-05-22T07:43:57.000Z</published>
    <updated>2022-05-24T03:16:27.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android知识学习"><a href="#Android知识学习" class="headerlink" title="Android知识学习"></a>Android知识学习</h1><h2 id="1-ARM汇编指令"><a href="#1-ARM汇编指令" class="headerlink" title="1.ARM汇编指令"></a>1.ARM汇编指令</h2><p>​    之前打交道比较多的是x86指令集，接触过一点Mips指令集，对于arm指令集还没系统学习过</p><h3 id="1-1-arm的运行状态"><a href="#1-1-arm的运行状态" class="headerlink" title="1.1 arm的运行状态"></a>1.1 arm的运行状态</h3><p>​    arm分为七种运行模式和两种运行状态。</p><p>​    运行模式即用户模式(类似windows的ring3程序)，系统模式(类似ring0)，…等</p><p>​    运行状态分为ARM和Thumb状态。</p><p>​    <strong>1.1.a. Thumb状态</strong></p><p>​    Thumb状态是2字节，可以看做是ARM指令压缩形式的子集,具有16位的代码密度(也就是2个字节指令长度),但是只能是支持通用功能,必要的时候仍然需要ARM 指令。</p><h3 id="1-2-arm寄存器"><a href="#1-2-arm寄存器" class="headerlink" title="1.2 arm寄存器"></a>1.2 arm寄存器</h3><p>​    arm寄存器一共有37个，其中31个通用的，6个是状态寄存器。其中<strong>31</strong>个中分为未分组寄存器和分组寄存器。</p><p>​    <strong>未分组寄存器</strong></p><p>​    1.R0-R7，其意义是在各种运行模式下都可以使用的通用寄存器。R0-R7是通用寄存器，其中<strong>R0-R3</strong>可以用来传递参数，返回值。如果传参的时候寄存器不够的话就使用压栈来完成了。结果返回的寄存器是R0。</p><p>​    <strong>分组寄存器</strong></p><p>​    1.分组寄存器也就是说在不同模式下，会有不同的寄存器，R8-R12是较为特殊的，因为只有在快速模式(FIQ)下,其名字才不一样。也是通用寄存器，可以用来存局部变量之类的。</p><p>​    2. R11寄存器，代表栈底指针。</p><p>​    3.R13寄存器，代表sp栈顶指针。</p><p>​    4.R14寄存器，也叫LR寄存器，即链接寄存器，可以用作保存子程序或者中断的返回地址。</p><p>​    5.R15寄存器，PC寄存器，类似于EIP。</p><p>​    6.CPSR状态寄存器，类似于EFLAGS寄存器。其中的第五位为1时则代表运行在ARM状态，如果T=0则代表运行在Thumb状态。</p><h3 id="1-3-arm-64寄存器"><a href="#1-3-arm-64寄存器" class="headerlink" title="1.3 arm 64寄存器"></a>1.3 arm 64寄存器</h3><p>​    本质上没有什么不同，详情可以见<a href="https://support.huaweicloud.com/ref-kunpenggrf/kunpenggrffaq_10_0057.html" target="_blank" rel="noopener">https://support.huaweicloud.com/ref-kunpenggrf/kunpenggrffaq_10_0057.html</a></p><p>​    比较有意思的是X16,X17寄存器</p><p>​    x16~x17是Intra-procedure-call scratch registers。也就是调用的函数里会用到的一些寄存器(又叫IP0,IP1),比如常用于动态链接中的plt寻址等指令。比如以下指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. adrp  x16, 11000 &lt;func22+0x10b30&gt; #adrp会拿到目标地址所在页的基址，这里应该就是相应的got表地址了</span><br><span class="line">2. ldr x17, [x16]</span><br><span class="line">3. add x16, x16,</span><br><span class="line">4. br x17</span><br></pre></td></tr></table></figure><h2 id="2-调用约定"><a href="#2-调用约定" class="headerlink" title="2.调用约定"></a>2.调用约定</h2><h3 id="2-1-arm-arm64调用约定"><a href="#2-1-arm-arm64调用约定" class="headerlink" title="2.1 arm/arm64调用约定"></a>2.1 arm/arm64调用约定</h3><p>​    ARM和ARM64使用的是ATPCS(ARM-Thumb Procedure Call Standard/ARM-Thumb过程调用标准)的函数调用约定。</p><p>​    ARM会把参数保存到R0-R3寄存器中，剩下的参数从右到左压栈。返回值放在R0中。</p><p>​    ARM64则是参数保存至X0-X7寄存器中，上下的参数从右到左入栈，返回值放在X0中。</p><h3 id="2-2-x86调用约定"><a href="#2-2-x86调用约定" class="headerlink" title="2.2 x86调用约定"></a>2.2 x86调用约定</h3><p>​    顺便说一下x86的调用约定，x86可以分为三种调用约定: cdecl/stdcall/fastcall。cdecl/stdcall是直接压栈，参数从右往左依次入栈，返回值放在EAX寄存器中。fastcall则是参数1，2保存在ECX,EDX中，剩下的参数从右往左依次入栈。结果放在EAX寄存器中。</p><p>​    x64则只有fastcall一种调用约定，参数1，2，3，4保存至RCX,RDX,R8,R9中，剩下参数从右往左依次入栈。</p><h3 id="2-3-C-函数调用约定"><a href="#2-3-C-函数调用约定" class="headerlink" title="2.3 C++函数调用约定"></a>2.3 C++函数调用约定</h3><p>​    西加加是遵循thiscall函数调用约定，对于x86，会把this指针存入ECX。x64则是参数1，2，3存在RDX，R8，R9，this指针存入ECX。</p><p>​    对于ARM而言，则是把this指针存在R0中，参数1，2，3存在R1,R2,R3。ARM64则是this指针存在X0中，参数1-7存放在X0-X7中，剩下参数从右到左入栈。</p><h2 id="3-跳转指令"><a href="#3-跳转指令" class="headerlink" title="3.跳转指令"></a>3.跳转指令</h2><p>​    ARM的跳转指令有B,BL,BX,BLX。</p><p>​    1.跳转指令B就是无条件跳转，类似于jmp指令。用法: B label</p><p>​    2.BL指令则是带返回的跳转指令，跳转之前会在R14(LR寄存器)中存入当前PC的值。类似于call指令。用法: BL label</p><p>​    3.BX则是带状态切换的跳转指令，根据operand的最低位来判断,如果是1则是Thumb状态，如果是0则是ARM状态。用法：BX 寄存器</p><p>​    4.BLX则是带返回和状态切换的，如果用法是BLX label，则一定会更改处理器的状态。如果是BLX 寄存器，则根据其在最低为来决定。</p><p>​    还有BNE,BEQ这些根据状态寄存器的条件跳转指令。。。除了跳转指令之外，还可以通过MOV,LDR指令，把地址直接赋给PC寄存器从而实现跳转。如MOV PC, LR。或者LDR PC,=0xFFFFFFFF(加等号表示是伪指令，直接把0xFFFFFFFF赋值给PC，否则是去该地址上取值)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android知识学习&quot;&gt;&lt;a href=&quot;#Android知识学习&quot; class=&quot;headerlink&quot; title=&quot;Android知识学习&quot;&gt;&lt;/a&gt;Android知识学习&lt;/h1&gt;&lt;h2 id=&quot;1-ARM汇编指令&quot;&gt;&lt;a href=&quot;#1-ARM汇编指</summary>
      
    
    
    
    
    <category term="android" scheme="http://pidanxu.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android study 2</title>
    <link href="http://pidanxu.github.io/2022/05/13/android-study-2/"/>
    <id>http://pidanxu.github.io/2022/05/13/android-study-2/</id>
    <published>2022-05-13T13:18:19.000Z</published>
    <updated>2022-05-22T07:37:10.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-native-hook原理"><a href="#Android-native-hook原理" class="headerlink" title="Android native hook原理"></a>Android native hook原理</h1><h1 id="1-android-got-hook"><a href="#1-android-got-hook" class="headerlink" title="1. android got hook"></a>1. android got hook</h1><h2 id="1-1-GOT-AND-PLT"><a href="#1-1-GOT-AND-PLT" class="headerlink" title="1.1 GOT AND PLT"></a>1.1 GOT AND PLT</h2><p>​    和windows的IAT HOOK一样，当程序调用外部函数时，需要先跳转到PLT(<code>Procedure Link Table</code> 程序链接表，位于代码段)，再跳转到GOT(<code>Global Offset Table</code> 全局偏移表，位于数据段)，执行目标函数。</p><p>​    既然GOT表中已经有了外部函数的真实地址，为什么还需要PLT表呢？因为存在延迟绑定(<code>Lazy Binding</code>)：当外部函数被调用时，才进行地址解析和重定位。所以PLT表是服务于延迟绑定而存在的。</p><p>​    PLT表内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp got[xx]#第一次调用前，linker会把got表相应的函数填为该jmp的下一条指令</span><br><span class="line">pushq $0x? #可以认为是函数标志，告诉_dl_runtime_resolve函数要填哪个函数的got表地址</span><br><span class="line">jmp _dl_runtime_resolve #让Linker填写GOT表地址</span><br></pre></td></tr></table></figure><h2 id="1-2-如何完成got-hook"><a href="#1-2-如何完成got-hook" class="headerlink" title="1.2 如何完成got hook?"></a>1.2 如何完成got hook?</h2><p>​    在已经完成注入的情况下，要完成got hook可以拆分为以下四个步骤。感觉和ctf 的一些简单pwn题差异不大，pwn需要泄露基地址，泄露libc的加载地址。只不过呢，pwn菜单题里面拿got表地址是直接拖到IDA里面去拿，而且要找漏洞利用点去覆写got表。got hook因为是已经完成注入，所以可以直接写，只需要解析elf文件自动拿到got偏移和so加载地址就好了。</p><p>​    1.找到GOT表在ELF文件中的偏移</p><p>​    2.找到GOT表所在模块加载的基址</p><p>​    3.定位到想要hook的函数</p><p>​    4.将自定义函数的地址进行覆盖</p><h2 id="2-inline-hook"><a href="#2-inline-hook" class="headerlink" title="2.inline hook"></a>2.inline hook</h2><p>​    inline hook就是把目标函数的前几条指令改为jmp 指令，jmp到一块shellcode的地方，然后在shellcode的地方调用自己已经注册的自定义函数，然后再执行之前被覆盖的指令，最后跳回目标函数位置。</p><h2 id="3-Exception-hook"><a href="#3-Exception-hook" class="headerlink" title="3.Exception hook"></a>3.Exception hook</h2><h3 id="3-1-Exception-hook原理"><a href="#3-1-Exception-hook原理" class="headerlink" title="3.1 Exception hook原理"></a>3.1 Exception hook原理</h3><p>​    Exception hook的缺点是执行效率较低，原理是每次在目标指令处制造一个不合法指令，这样进程执行到目标指令处会收到信号<em>SIGILL</em>（illegal instruction），从而进入到我们可以注册的Signal handler中，在异常处理函数中首先执行自定义逻辑，然后把原目标指令恢复，把下一条目标指令改为非法指令即可。</p><h3 id="3-2-如何注册signal-handler"><a href="#3-2-如何注册signal-handler" class="headerlink" title="3.2 如何注册signal handler"></a>3.2 如何注册signal handler</h3><p>​    使用sigaction函数，详情见<a href="https://www.man7.org/linux/man-pages/man2/sigaction.2.html。这个函数是用来在接收到异常信号后进行处理的，第二个结构体参数里面可以放入用户自定义的处理函数。" target="_blank" rel="noopener">https://www.man7.org/linux/man-pages/man2/sigaction.2.html。这个函数是用来在接收到异常信号后进行处理的，第二个结构体参数里面可以放入用户自定义的处理函数。</a></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://www.cnblogs.com/mmmmar/p/8227915.html" target="_blank" rel="noopener">https://www.cnblogs.com/mmmmar/p/8227915.html</a></p><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-native-hook原理&quot;&gt;&lt;a href=&quot;#Android-native-hook原理&quot; class=&quot;headerlink&quot; title=&quot;Android native hook原理&quot;&gt;&lt;/a&gt;Android native hook原理&lt;/</summary>
      
    
    
    
    
    <category term="android-hook" scheme="http://pidanxu.github.io/tags/android-hook/"/>
    
  </entry>
  
  <entry>
    <title>android study 1</title>
    <link href="http://pidanxu.github.io/2022/05/10/android-study-1/"/>
    <id>http://pidanxu.github.io/2022/05/10/android-study-1/</id>
    <published>2022-05-09T16:06:33.000Z</published>
    <updated>2022-05-12T13:04:26.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Frida、Xposed原理"><a href="#Frida、Xposed原理" class="headerlink" title="Frida、Xposed原理"></a>Frida、Xposed原理</h1><h2 id="1-胡说八道"><a href="#1-胡说八道" class="headerlink" title="1.胡说八道"></a>1.胡说八道</h2><p>​    我对于hook原理的想法就是，要么把地址替换了(如got hook)，要么插入一些代码劫持控制流完成自己的功能(如inline hook)。</p><p>​    Frida/Xposed使用的是动态二进制插桩技术，可以在程序运行的时候注入代码。</p><p>​    对于Android 5.0以下，采用dalvik虚拟机，frida和xposed这时的原理是相同的。</p><h2 id="2-xposed-hook原理"><a href="#2-xposed-hook原理" class="headerlink" title="2.xposed hook原理"></a>2.xposed hook原理</h2><h3 id="2-1-background："><a href="#2-1-background：" class="headerlink" title="2.1 background："></a>2.1 background：</h3><p>​    android启动的第一个用户空间进程是Init进程，init随后会创建zygote进程，android应用程序进程都是由zygote fork出来的。zygote对应的二进制程序是app_process，xposed 框架就是通过替换系统的 app_process 可执行文件以及虚拟机动态链接库，让 zygote 在启动应用程序进程时注入框架代码，进而实现对应用程序进程的劫持。</p><p>​    zygote进程启动流程如下：</p><ol><li>调用 AppRuntime start 方法，启动 zygote 进程。</li><li>创建 Java 虚拟机，并为虚拟机注册 JNI 方法。成为java进程的母体，用于孵化java进程</li><li>通过 JNI 调用 ZygoteInit 的 main 方法进入 Java 框架层。</li><li>注册服务端 Socket ，等待 ActivityManagerService 请求创建应用程序进程。</li><li><p>开启 SystemServer 进程。</p><p>总的来说可以参考下图</p></li></ol><img src="/2022/05/10/android-study-1/start_zygote_flow.jpg"><h3 id="2-2-xposed-java-method-hook原理"><a href="#2-2-xposed-java-method-hook原理" class="headerlink" title="2.2 xposed java method hook原理"></a>2.2 xposed java method hook原理</h3><p>​    Xposed ，就是用自己实现的app_process替换掉了系统原本提供的app_process，加载一个额外的jar包，然后入口从原来的<code>com.android.internal.osZygoteInit.main()</code>被替换成了<code>de.robv.android.xposed.XposedBridge.main()</code>，然后创建的Zygote进程就变成Hook的Zygote进程了，而后面zygote Fork出来的进程也是被Hook过的。这个Jar包XposedBridge.jar，就会被加载到每个安卓进程中。这样一来就可以完成对zygote创建出来的dalvik虚拟机的劫持，从而修改Method结构体，将java method改为native method。然后这个native method其实就是需要插进去的<strong>自定义函数</strong>，最后自定义函数运行完再调用被Hook的原函数。</p><p>​    XposedBridge有一个私有的Native方法：hookMethodNative，这个方法也在app_process中使用。该函数提供一个方法对象利用Java的反射机制来对内置的方法覆写。zygote进程加载XposedBridge将所有需要替换的Method通过JNI方法hookMethodNative指向Native方法</p><h3 id="2-3-xposed检测方法"><a href="#2-3-xposed检测方法" class="headerlink" title="2.3 xposed检测方法"></a>2.3 xposed检测方法</h3><ol><li><strong>通过PackageManager查看安装列表</strong>,通过调用Package Manager API，看安装的app中是否有Xposed Installer</li><li><strong>制造异常读取栈</strong>，既然xposed会劫持每个安卓进程，那么在处理异常的栈里也应该出现xposed的身影</li><li><strong>检测是否有java methodB变为native method</strong>,通过反射调用Modifier.isNative(method.getModifiers()),看是否有相关的Java method变成了Native method。从而判断是否有xposed进来Hook了。</li><li><strong>通过反射读取XposedHelper字段</strong>，读取methodCache(hashmap)相关变量,如果key中有来自app的方法，则可认为有xposed注入。</li><li><strong>在Native层使用c/c++解析/proc/self/maps文件</strong>，检测app加载的库里是否有XposedBridge.jar的存在。</li></ol><h2 id="3-Frida-hook原理"><a href="#3-Frida-hook原理" class="headerlink" title="3. Frida hook原理"></a>3. Frida hook原理</h2><h3 id="3-1-Frida-注入代码原理"><a href="#3-1-Frida-注入代码原理" class="headerlink" title="3.1 Frida 注入代码原理"></a>3.1 Frida 注入代码原理</h3><h4 id="3-1-1-ptrace"><a href="#3-1-1-ptrace" class="headerlink" title="3.1.1 ptrace"></a>3.1.1 ptrace</h4><p>​    ptrace是linux提供的API函数, 它可以监视和控制进程运行，可以动态修改进程的内存，寄存器值。它一般被用来调试。ida动态调试so，就是基于ptrace实现的。因为一个进程只能被ptrace一次, 所以进程可以自己ptrace自己，这样ida和别的基于ptrace的工具和调试器或就无法调试这个进程了。ptrace注入流程如下:</p><p>​    1.attach到远程进程；<br>​    2.保存寄存器环境<br>​    3.远程调用mmap函数分配内存空间<br>​    4.向远程进程写入加载模块名称和调用函数<br>​    5.通过dlopne打开注入模块<br>​    6.dlsym获取调用函数地址<br>​    7.远程调用注入模块的函数<br>​    8.恢复寄存器<br>​    9.剥离远程进程</p><h3 id="3-1-2-Frida通过ptrace注入"><a href="#3-1-2-Frida通过ptrace注入" class="headerlink" title="3.1.2 Frida通过ptrace注入"></a>3.1.2 Frida通过ptrace注入</h3><p>​    Frida是通过ptrace在进程里注入一个agent，然后通过agent来完成hook。</p><p>​    什么是agent?agent是Frida注入到进程中的动态库。</p><p>​    <strong>frida 的进程注入是通过 ptrace 实现的</strong>，注入之后会在远端进程分配一段内存将 agent 拷贝过去并在目标进程中执行代码，<strong>执行完成后会 detach 目标进程</strong>。frida-agent 注入到目标进程并启动后会启动一个新进程与 host 进行通信，从而 host 可以给目标进行发送命令，比如执行代码，激活/关闭 hook，同时也能接收到目标进程的执行返回以及异步事件信息等。</p><h3 id="3-2-额外插一句System-server-agent"><a href="#3-2-额外插一句System-server-agent" class="headerlink" title="3.2 额外插一句System-server agent"></a>3.2 额外插一句System-server agent</h3><p>​    除了注入到目标进程的 agent，还有一个 agent，即 <code>system_server_agent</code>。</p><p>​    Frida会用该agent对SystemServer 进行注入，参考2.1节内容，可知SystemServer 是zygote中启动的第一个进程，同时也是系统中启动的第一个java进程，其中包含了AMS和PMS等系统服务。对SystemService注入，Frida则可以获取系统中的应用信息，以及可以完成一些相应的功能</p><p>​    以获取当前窗口中展示在最上层的应用功能为例，接口为 <code>get_frontmost_application</code>，最终的实现在 <code>SystemServerAgent</code>:</p><h3 id="3-3-Frida的ART-HOOK实现"><a href="#3-3-Frida的ART-HOOK实现" class="headerlink" title="3.3 Frida的ART HOOK实现"></a>3.3 Frida的ART HOOK实现</h3><h4 id="3-3-1-art和dalvik的区别"><a href="#3-3-1-art和dalvik的区别" class="headerlink" title="3.3.1 art和dalvik的区别"></a>3.3.1 art和dalvik的区别</h4><p>​    Dalvik虚拟机是基于apache的java虚拟机，并被改进以适应低内存，低处理器速度的移动设备环境。Dalvik虚拟机依赖于Linux内核，实现进程隔离与线程调试管理，安全和异常管理，垃圾回收等重要功能。</p><p>​    dalvik依靠JIT(Just-In-Time)编译器去解释字节码。JIT 编译器可以对执行次数频繁的 dex/odex 代码进行编译与优化，将 dex/odex 中的 Dalvik Code（Smali 指令集）翻译成相当精简的 Native Code 去执行。但是问题在于，JIT每次启动都需要重新编译。</p><p>​    ART(android runtime)，相比于dalvik是更加高效的。在于ART引进了一种AOT(ahead of time)的编译策略，Android 7.0后，AOT和JIT是混合存在于ART中的。AOT编译策略会在安装的时候就预编译字节码到机器码，形成quick code模式。quick code模式即通过AOT将Java方法在APP安装时预先编译成机器码以后，在运行时直接执行。那么当然，AOT并不是一定比JIT好的，否则现在ART中也不会是两者并存的模式。</p><p><strong>JIT编译模式的缺点：</strong></p><ul><li>每次启动应用都需要重新编译；</li><li>运行时比较耗电，造成电池额外的开销；</li></ul><p><strong>AOT编译模式的缺点：</strong></p><ul><li>应用安装和系统升级之后的应用优化比较耗时；</li><li><p>优化后文件会占用额外的存储空间；</p><p> 所以呢，应用程序安装时不会将字节码全部编译成机器码，而是在运行时将热点代码编译成机器码。因此在Android系统中，Java方法的执行大概可以分为直接执行机器码（AOT），以及使用解释器解释执行两种模式（JIT）。</p></li></ul><h4 id="3-3-2-art-java-hook原理"><a href="#3-3-2-art-java-hook原理" class="headerlink" title="3.3.2 art java hook原理"></a>3.3.2 art java hook原理</h4><p>​    前面说的两种模式即quick code 模式(直接执行arm机器码)和Interpreter模式(解释执行)。</p><img src="/2022/05/10/android-study-1/art_native_execute.png"><p>​    从上图可以看出，对于一个native method, ART虚拟机首先会尝试quickcode模式执行，检查ARTMethod结构中的entry_point_from_quick_compiled_code成员，这里分3种情况：</p><ol><li>如果函数已经存在quick code, 则指向这个函数对应的 quick code的起始地址，而当quick code不存在时，它的值则会代表其他的意义；</li><li>当一个 java 函数不存在 quick code时，它的值是函数 artQuickToInterpreterBridge 的地址，用以从 quick 模式切换到 Interpreter 模式来解释执行 java 函数代码；</li><li>当一个 java native（JNI）函数不存在 quick code时，它的值是函数 art_quick_generic_jni_trampoline 的地址，用以执行没有quick code的 jni 函数；</li></ol><p>​    那么Frida把一个java method 变成native method类型，是肯定没有quick code的，这时候就需要将entry_point_from_quick_compiled_code成员修改为art_quick_generic_jni_trampoline 的地址。art_quick_generic_jni_trampoline最终会调到entry_point_from_jni，即jni函数的入口。Frida把entry_point_from_jni改为自定义代码的入口，即可达到目的。</p><p>​    Frida把java method改为jni method，需要修改ARTMethod结构体中的这几个值：<br>​    access<em>flags</em> = native<br>​    entry_point_from<em>jni</em> = 自定义代码的入口<br>​    entry_point_from_quick_compiled_code = art_quick_generic_jni_trampoline函数的地址<br>​    entry_point_from_interpreter = artInterpreterToCompiledCodeBridge函数地址(把以interpreter模式调用入口地址指向    artInterpreterToCompiledCodeBridge)</p><h4 id="3-3-3-art-native-hook原理"><a href="#3-3-3-art-native-hook原理" class="headerlink" title="3.3.3 art native hook原理"></a>3.3.3 art native hook原理</h4><p>​    这个我暂时没查到太多资料，改天看看英文参考资料补充一下。</p><p>​    大概就是Frida就是在进程里面注入一个agent，然后agent来inline hook那一套。</p><h2 id="4-References"><a href="#4-References" class="headerlink" title="4.References"></a>4.References</h2><p>ref:<a href="https://mabin004.github.io/2018/07/31/Mac上编译Frida/" target="_blank" rel="noopener">Frida源码分析 | m4bln (mabin004.github.io)</a></p><p>ref:<a href="https://www.jianshu.com/p/51e6aef175a2" target="_blank" rel="noopener">hook工具frida原理及使用 - 简书 (jianshu.com)</a></p><p>ref:<a href="https://www.pythonf.cn/read/164792" target="_blank" rel="noopener">https://www.pythonf.cn/read/164792</a></p><p>ref:<a href="https://zhuanlan.zhihu.com/p/389889716" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/389889716</a></p><p>ref:<a href="https://frida.re/slides/osdc-2015-the-engineering-behind-the-reverse-engineering.pdf" target="_blank" rel="noopener">https://frida.re/slides/osdc-2015-the-engineering-behind-the-reverse-engineering.pdf</a></p><p>ref:<a href="https://tinyniko.github.io/2020/02/12/%E6%97%A7%E5%8D%9A%E5%AE%A2%E5%BC%95%E5%AF%BC/Frida.pdf" target="_blank" rel="noopener">https://tinyniko.github.io/2020/02/12/%E6%97%A7%E5%8D%9A%E5%AE%A2%E5%BC%95%E5%AF%BC/Frida.pdf</a></p><p>ref: <a href="https://evilpan.com/2022/04/09/frida-core/" target="_blank" rel="noopener">https://evilpan.com/2022/04/09/frida-core/</a></p><p>ref:<a href="https://xw.qq.com/cmsid/20211201A07SF300" target="_blank" rel="noopener">【创宇小课堂】移动安全-xposed检测原理|xposed|zygote|dalvik|java|xposed框架|虚拟机 (qq.com)</a></p><p>ref: <a href="https://cloud.tencent.com/developer/article/1578515" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1578515</a></p><p>ref: <a href="https://tech.meituan.com/2018/02/02/android-anti-hooking.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/02/02/android-anti-hooking.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Frida、Xposed原理&quot;&gt;&lt;a href=&quot;#Frida、Xposed原理&quot; class=&quot;headerlink&quot; title=&quot;Frida、Xposed原理&quot;&gt;&lt;/a&gt;Frida、Xposed原理&lt;/h1&gt;&lt;h2 id=&quot;1-胡说八道&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="android-hook" scheme="http://pidanxu.github.io/tags/android-hook/"/>
    
  </entry>
  
  <entry>
    <title>huaweictf2020</title>
    <link href="http://pidanxu.github.io/2020/12/28/huaweictf2020/"/>
    <id>http://pidanxu.github.io/2020/12/28/huaweictf2020/</id>
    <published>2020-12-28T13:55:41.000Z</published>
    <updated>2021-02-18T05:13:32.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020华为CTF"><a href="#2020华为CTF" class="headerlink" title="2020华为CTF"></a>2020华为CTF</h1><p>三场比赛的时候都没啥时间，匆匆看了几道题</p><h2 id="第一场"><a href="#第一场" class="headerlink" title="第一场"></a>第一场</h2><p>divination</p><p>主要逻辑就是循环左移,循环右移,异或。那其实每个bit就是循环移位过后的二进制加法，可以视为一个线性方程组。用sage进行求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">rol = <span class="keyword">lambda</span> val, r_bits, max_bits: \</span><br><span class="line"></span><br><span class="line">    (val &lt;&lt; r_bits%max_bits) &amp; (<span class="number">2</span>**max_bits<span class="number">-1</span>) | \</span><br><span class="line"></span><br><span class="line">    ((val &amp; (<span class="number">2</span>**max_bits<span class="number">-1</span>)) &gt;&gt; (max_bits-(r_bits%max_bits)))</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># Rotate right: 0b1001 --&gt; 0b1100</span></span><br><span class="line"></span><br><span class="line">ror = <span class="keyword">lambda</span> val, r_bits, max_bits: \</span><br><span class="line"></span><br><span class="line">    ((val &amp; (<span class="number">2</span>**max_bits<span class="number">-1</span>)) &gt;&gt; r_bits%max_bits) | \</span><br><span class="line"></span><br><span class="line">    (val &lt;&lt; (max_bits-(r_bits%max_bits)) &amp; (<span class="number">2</span>**max_bits<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">max_bits = <span class="number">256</span>  <span class="comment"># For fun, try 2, 17 or other arbitrary (positive!) values</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(input)</span>:</span></span><br><span class="line"></span><br><span class="line">list1=[<span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>, <span class="number">103</span>, <span class="number">107</span>, <span class="number">109</span>, <span class="number">113</span>, <span class="number">127</span>]</span><br><span class="line"></span><br><span class="line">xor_res=input</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(list1)):</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">t1=rol(input,list1[i],<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">t1=ror(input,list1[i],<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">xor_res=(xor_res^^t1)&amp; <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(xor_res),hex(t1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> xor_res</span><br></pre></td></tr></table></figure><p><strong>solve.exp</strong></p><p>把f变换视为变换视为A*B=C</p><p>32字节的flag，可以视为256个未知数(每个bit为一个未知数),A为256<em>256的参数矩阵，B为1\</em>256的未知数向量，C为密文。</p><p>那么为了求得A矩阵，我们可以构造256<em>256个随机数矩阵B1，得A\</em>B1=C1。那么C1，B1已知，自然能得到矩阵A，从而得到A的逆矩阵~A,那么B=~A*C,自然求得未知数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">rol = <span class="keyword">lambda</span> val, r_bits, max_bits: \</span><br><span class="line">    (val &lt;&lt; r_bits%max_bits) &amp; (<span class="number">2</span>**max_bits<span class="number">-1</span>) | \</span><br><span class="line">    ((val &amp; (<span class="number">2</span>**max_bits<span class="number">-1</span>)) &gt;&gt; (max_bits-(r_bits%max_bits)))</span><br><span class="line"><span class="comment"># Rotate right: 0b1001 --&gt; 0b1100</span></span><br><span class="line">ror = <span class="keyword">lambda</span> val, r_bits, max_bits: \</span><br><span class="line">    ((val &amp; (<span class="number">2</span>**max_bits<span class="number">-1</span>)) &gt;&gt; r_bits%max_bits) | \</span><br><span class="line">    (val &lt;&lt; (max_bits-(r_bits%max_bits)) &amp; (<span class="number">2</span>**max_bits<span class="number">-1</span>))</span><br><span class="line">max_bits = <span class="number">256</span>  <span class="comment"># For fun, try 2, 17 or other arbitrary (positive!) values</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(input)</span>:</span></span><br><span class="line">list1=[<span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>, <span class="number">103</span>, <span class="number">107</span>, <span class="number">109</span>, <span class="number">113</span>, <span class="number">127</span>]</span><br><span class="line">xor_res=input</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(list1)):</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">t1=rol(input,list1[i],<span class="number">256</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">t1=ror(input,list1[i],<span class="number">256</span>)</span><br><span class="line">xor_res=(xor_res^^t1)&amp; <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span></span><br><span class="line"><span class="keyword">print</span> hex(xor_res),hex(t1)</span><br><span class="line"><span class="keyword">return</span> xor_res</span><br><span class="line"><span class="keyword">print</span> <span class="comment">#hex(rol(0x3132333435363738393031323334353637383930313233343536373839303132,0xd,256))</span></span><br><span class="line"><span class="keyword">print</span> hex(rol(<span class="number">0x3231303938373635343332313039383736353433323130393837363534333231</span>,<span class="number">0xd</span>,<span class="number">256</span>))</span><br><span class="line"><span class="keyword">print</span> hex(f(<span class="number">0x3231303938373635343332313039383736353433323130393837363534333231</span>))</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calL</span><span class="params">()</span>:</span></span><br><span class="line">    t = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):        t.append(random.randint(<span class="number">0</span>,<span class="number">0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span>))</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> t:</span><br><span class="line">        tmp.append(f(x))</span><br><span class="line">    inp = t</span><br><span class="line">    outp = tmp</span><br><span class="line">    I = Integers(<span class="number">2</span>)</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> inp:</span><br><span class="line">        t =map(int ,bin(x)[<span class="number">2</span>:].zfill(<span class="number">256</span>))</span><br><span class="line">        tmp.append(t)</span><br><span class="line">    a = matrix(I,tmp)</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> outp:</span><br><span class="line">        t =map(int ,bin(x)[<span class="number">2</span>:].zfill(<span class="number">256</span>))</span><br><span class="line">        tmp.append(t)</span><br><span class="line">    b = matrix(I,tmp)</span><br><span class="line">    L =  a.solve_right(b)</span><br><span class="line">    L =  L</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line">L  = calL()</span><br><span class="line"><span class="keyword">print</span> L</span><br><span class="line">ans = [<span class="number">0xe7764526f1acd0de2548d47dbf701b1988645a56c60fcf307a043dd816d74e5a</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recover</span><span class="params">(c,L)</span>:</span></span><br><span class="line">    I = Integers(<span class="number">2</span>)</span><br><span class="line">    tmp = []</span><br><span class="line">    t =map(int ,bin(c)[<span class="number">2</span>:].zfill(<span class="number">256</span>))</span><br><span class="line">    v = vector(I,t)</span><br><span class="line">    r = v*L</span><br><span class="line">    <span class="keyword">return</span> int(<span class="string">''</span>.join( map(str,map(int,r)) ),<span class="number">2</span>)</span><br><span class="line">L = ~L</span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="number">0x5A</span>,<span class="number">0x4E</span>,<span class="number">0xD7</span>,<span class="number">0x16</span>,<span class="number">0xD8</span>,<span class="number">0x3D</span>,<span class="number">4</span>,<span class="number">0x7A</span>,<span class="number">0x30</span>,<span class="number">0xCF</span>,<span class="number">0xF</span>,<span class="number">0xC6</span>,<span class="number">0x56</span>,<span class="number">0x5A</span>,<span class="number">0x64</span>,<span class="number">0x88</span>,<span class="number">0x19</span>,<span class="number">0x1B</span>,<span class="number">0x70</span>,<span class="number">0xBF</span>,<span class="number">0x7D</span>,<span class="number">0xD4</span>,<span class="number">0x48</span>,<span class="number">0x25</span>,<span class="number">0xDE</span>,<span class="number">0xD0</span>,<span class="number">0xAC</span>,<span class="number">0xF1</span>,<span class="number">0x26</span>,<span class="number">0x45</span>,<span class="number">0x76</span>,<span class="number">0xE7</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> ans:</span><br><span class="line">tmp = recover(k,L)</span><br><span class="line"><span class="keyword">print</span> hex(tmp)</span><br><span class="line">s = hex(tmp)[<span class="number">2</span>:].decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">print</span> s</span><br><span class="line">flag+=s</span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure><h3 id="第二场"><a href="#第二场" class="headerlink" title="第二场"></a>第二场</h3><p>题目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag </span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> next_prime,invert,gcd</span><br><span class="line"><span class="keyword">import</span> os                              </span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"><span class="comment">## level1</span></span><br><span class="line">x = getPrime(<span class="number">290</span>)</span><br><span class="line">y = next_prime(<span class="number">21</span>*x)</span><br><span class="line">z = next_prime(<span class="number">3</span>*x*y)</span><br><span class="line">n1 = x*y*z</span><br><span class="line">msg = flag+os.urandom(<span class="number">100</span>)</span><br><span class="line">m = bytes_to_long(msg)</span><br><span class="line"><span class="keyword">assert</span>(m &lt; n1)</span><br><span class="line"><span class="keyword">print</span> n1</span><br><span class="line">c1 = pow(m,e,n1)</span><br><span class="line"></span><br><span class="line"><span class="comment">## level2</span></span><br><span class="line">m = c1</span><br><span class="line">o = getPrime(<span class="number">300</span>) </span><br><span class="line">s = getPrime(<span class="number">300</span>)</span><br><span class="line">t = next_prime(o)</span><br><span class="line">u = next_prime(s)</span><br><span class="line"><span class="keyword">print</span> o*s</span><br><span class="line">n2 = o*s*t*u</span><br><span class="line"><span class="keyword">assert</span>(m&lt;n2)</span><br><span class="line"><span class="keyword">print</span> n2</span><br><span class="line">c2 = pow(m,e,n2)</span><br><span class="line"><span class="comment">## level3</span></span><br><span class="line">m = c2</span><br><span class="line">p = getPrime(<span class="number">800</span>)</span><br><span class="line">q = getPrime(<span class="number">800</span>)</span><br><span class="line"></span><br><span class="line">n3 = p * q</span><br><span class="line">phi = (q<span class="number">-1</span>)*(p<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">assert</span>(m &lt; n3)</span><br><span class="line"><span class="keyword">print</span> n3</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    s = getPrime(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span>(gcd(s,p<span class="number">-1</span>) == <span class="number">1</span>):</span><br><span class="line">        sinv = invert(s,p<span class="number">-1</span>)</span><br><span class="line">        e = <span class="number">4</span>*s*sinv+<span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span>(gcd(phi,e) == <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">c3 = pow(m,e,n3)</span><br><span class="line"><span class="keyword">print</span> c3</span><br><span class="line">m = bytes_to_long(os.urandom(<span class="number">128</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> m</span><br><span class="line"><span class="keyword">assert</span>(m&lt;n3)</span><br><span class="line"><span class="keyword">print</span> pow(m,e,n3)</span><br></pre></td></tr></table></figure><p>从后往前，第三层</p><p>e=4*s*sinv+3=4<em>(1+k\</em>(p-1))+3=4*k*(p-1)+7</p><p>pow(m,e,p)=pow(m,7,p)</p><p>pow(m,e,n)-pow(m,7,n)=x*p % n</p><p>n=p*q</p><p>gcd(n,pow(m,e,n)-pow(m,7,n))=p</p><p>然后可以爆破s得到e</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os                              </span><br><span class="line"></span><br><span class="line">c4=<span class="number">22238585749689335043198360403653248049710943304594623939441271714322821476047298977043454290592085809700500599520080107736858423927071836758485527270617538166045213386679961664240306883126224169183649140929168343634245637578487850945986688768857954082116136864696582066988005306045105860368497626822666433678879698344619056273526837700698315346972423482713305543394110949178233504551465821354514535155389087138867576532139739270960823294873497825040963862751772914087741831403951901</span></span><br><span class="line">n3=<span class="number">24502730939655407292543436897382196297516664227273320602397906878696723372242877776550446563950867624819352853122033114711732125433588724779869985477495098802744344448915032607469954642257825855931872281908232331623829725043031800535739432133948607448362641204034546581444904408754892037110031202573463399201625812005615264689877537231974023870006792196961829162058446662172634212427186470724599941352830546043772969297733239518604749366684163813795999625784931375110137805143337329</span></span><br><span class="line">m4_old=<span class="number">81225738828166640599054154023183465870678960906769673605358084529196871174429427936591822589995476552044227730868809310992934103731850597399114246762836121101348301079296663951503688072299542357013093324718850936925265954204973634470836187733828189312553819810470405246669124171178070485118436102895117354417</span></span><br><span class="line"></span><br><span class="line">p3=gcd(n3,c4-pow(m4_old,<span class="number">7</span>,n3))</span><br><span class="line"><span class="keyword">print</span> p3</span><br><span class="line">q3=n3/p3</span><br><span class="line">phi3=(p3<span class="number">-1</span>)*(q3<span class="number">-1</span>)</span><br><span class="line">c3=<span class="number">2385064917660948806957457681641614888669217960607006360543268900921017481245498563263991410918604891314384810533439253814523067168636768976220059028108900592323119524657903364697700329145453517769093265052715204625870232288203427545150983037310876534801548309890853026234248412421497939811385725642492104262954059677793538707604205179344884142656842895567795000647837461835179395742399372683460208271310884657279893532539121893558143029933794905470899127632780110459122203796256514</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> range(<span class="number">2</span>**<span class="number">10</span>,<span class="number">2</span>**<span class="number">11</span>):</span><br><span class="line">    <span class="comment">#s = getPrime(10)</span></span><br><span class="line">    <span class="keyword">if</span>(gcd(s,p3<span class="number">-1</span>) == <span class="number">1</span>):</span><br><span class="line">        sinv = invert(s,p3<span class="number">-1</span>)</span><br><span class="line">        e = <span class="number">4</span>*s*sinv+<span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span>(gcd(phi3,e) == <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span>(powmod(m4_old,e,n3)==c4):</span><br><span class="line"><span class="keyword">print</span> <span class="string">'e3 is '</span>,e</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> s%<span class="number">10000</span>==<span class="number">0</span>:</span><br><span class="line"> <span class="keyword">print</span> s</span><br><span class="line">d3=invert(e3,phi3)</span><br><span class="line">m3=powmod(c3,d3,n3)</span><br><span class="line">c2=m3</span><br></pre></td></tr></table></figure><p>第二层t和o接近，u和s接近，所以我们设x=t-o,y=u-s</p><p>然后对x，y进行一个爆破。</p><p>已知o*s=a，(o+x)*(s+y)=b</p><p>我们想求o,x,s,y四个值</p><p>有（xy-((o+x)*(s+y)-o*s))^2=(xy-xs-xy-oy)^2=xs^2+oy^2+2xsoy</p><p>所以我们可以有(xs-oy)^2=xy-((o+x)*(s+y)-o*s))^2-4osxy</p><p>开根得到xs-oy或者oy-xs，那么我们用(o+x)*(s+y)-(os+xy+xs-oy)=2oy，2oy/y得到o值，得到四个o,x,s,y值</p><p>第一层</p><p>其实可以用<a href="https://www.alpertron.com.ar/ECM.HTM强行分解" target="_blank" rel="noopener">https://www.alpertron.com.ar/ECM.HTM强行分解</a></p><p>x = getPrime(290)<br>y = next_prime(21<em>x)<br>z = next_prime(3</em>x*y)</p><p>n1=xyz约等于x(21x)(3x21x)=3*21*21*x^4</p><p>所以其实n1/(3*21*21)然后开四次方可以得到x的近似值，然后在那附近爆破x就行了。</p><h3 id="第三场"><a href="#第三场" class="headerlink" title="第三场"></a>第三场</h3><p>因为忘记&amp;0xff了，所以以为求解工具有问题，撸了z3，sage，numpy三个板子。线性方程最好z3还是用Int，约束里不要做异或。粗心害死人啊</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> *</span><br><span class="line">flag=[Int(<span class="string">'flag[%d]'</span>%i)<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">42</span>)]</span><br><span class="line">s=Solver()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_models</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> s.check() == sat:</span><br><span class="line">        m = s.model()</span><br><span class="line">        <span class="keyword">yield</span> m</span><br><span class="line">        s.add(Or([sym() != m[sym] <span class="keyword">for</span> sym <span class="keyword">in</span> m.decls()]))</span><br><span class="line">xor_table=[<span class="number">0xA0</span></span><br><span class="line">,<span class="number">0xE4</span></span><br><span class="line">,<span class="number">0xBA</span></span><br><span class="line">,<span class="number">0xFB</span></span><br><span class="line">,<span class="number">0x10</span></span><br><span class="line">,<span class="number">0xDD</span></span><br><span class="line">,<span class="number">0xAC</span></span><br><span class="line">,<span class="number">0x65</span></span><br><span class="line">,<span class="number">0x8D</span></span><br><span class="line">,<span class="number">0xB</span></span><br><span class="line">,<span class="number">0x57</span></span><br><span class="line">,<span class="number">0x1A</span></span><br><span class="line">,<span class="number">0xE4</span></span><br><span class="line">,<span class="number">0x28</span></span><br><span class="line">,<span class="number">0x96</span></span><br><span class="line">,<span class="number">0xB3</span></span><br><span class="line">,<span class="number">0xC</span></span><br><span class="line">,<span class="number">0x79</span></span><br><span class="line">,<span class="number">0x4D</span></span><br><span class="line">,<span class="number">0x80</span></span><br><span class="line">,<span class="number">0x90</span></span><br><span class="line">,<span class="number">0x99</span></span><br><span class="line">,<span class="number">0x58</span></span><br><span class="line">,<span class="number">0xFE</span></span><br><span class="line">,<span class="number">0x50</span></span><br><span class="line">,<span class="number">0xD3</span></span><br><span class="line">,<span class="number">0xF9</span></span><br><span class="line">,<span class="number">0x3C</span></span><br><span class="line">,<span class="number">0xF</span></span><br><span class="line">,<span class="number">0xC1</span></span><br><span class="line">,<span class="number">0xE3</span></span><br><span class="line">,<span class="number">0xA6</span></span><br><span class="line">,<span class="number">0x39</span></span><br><span class="line">,<span class="number">0xC3</span></span><br><span class="line">,<span class="number">0x28</span></span><br><span class="line">,<span class="number">0x75</span></span><br><span class="line">,<span class="number">0xF8</span></span><br><span class="line">,<span class="number">0xC9</span></span><br><span class="line">,<span class="number">0xC8</span></span><br><span class="line">,<span class="number">0xCD</span></span><br><span class="line">,<span class="number">0x78</span></span><br><span class="line">,<span class="number">0x26</span>]</span><br><span class="line">data=[]</span><br><span class="line">tmp=int(argv[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">print</span> <span class="string">'key is '</span>,tmp</span><br><span class="line">data.append(tmp)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x1e</span>):</span><br><span class="line">res=<span class="number">16807</span> * (tmp % <span class="number">127773</span>) - <span class="number">2836</span> * (tmp // <span class="number">127773</span>)</span><br><span class="line"><span class="comment">#print hex(abs(res))</span></span><br><span class="line"><span class="keyword">if</span>(res&lt;<span class="number">0</span>):</span><br><span class="line">tmp=res+<span class="number">0x7FFFFFFF</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tmp=res</span><br><span class="line">data.append(tmp)</span><br><span class="line"><span class="keyword">print</span> map(hex,data)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0x1f</span>):</span><br><span class="line"><span class="comment">#print "%x + %x =%x"%(data[(j+3)%0x1f],data[j],data[(j+3)%0x1f]+data[j])</span></span><br><span class="line">data[(j+<span class="number">3</span>)%<span class="number">0x1f</span>]=(data[(j+<span class="number">3</span>)%<span class="number">0x1f</span>]+data[j])&amp;<span class="number">0xffffffff</span></span><br><span class="line"><span class="string">'''for j in range(42+1):</span></span><br><span class="line"><span class="string">#print "%x + %x =%x"%(data[(j+3)%0x1f],data[j],data[(j+3)%0x1f]+data[j])</span></span><br><span class="line"><span class="string">data[(j+3)%0x1f]=(data[(j+3)%0x1f]+data[(j)%0x1f])&amp;0xffffffff</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">div2</span><span class="params">(num)</span>:</span></span><br><span class="line"><span class="keyword">return</span> num//<span class="number">2</span></span><br><span class="line"><span class="keyword">print</span> map(hex,map(div2,data))</span><br><span class="line"><span class="keyword">print</span> map(hex,data)</span><br><span class="line">table1=[]</span><br><span class="line">input=<span class="string">'flag&#123;111111111111111111111111111111111111&#125;'</span></span><br><span class="line">input_list=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line">input_list.append(ord(input[i])^xor_table[i])</span><br><span class="line">v6=[<span class="number">0</span>]*<span class="number">42</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line">table2=[]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line"><span class="comment">#print "%x + %x =%x"%(data[(j+3)%0x1f],data[j],data[(j+3)%0x1f]+data[j])</span></span><br><span class="line">data[(i*<span class="number">42</span>+j+<span class="number">3</span>)%<span class="number">0x1f</span>]=(data[(i*<span class="number">42</span>+j+<span class="number">3</span>)%<span class="number">0x1f</span>]+data[(i*<span class="number">42</span>+j)%<span class="number">0x1f</span>])&amp;<span class="number">0xffffffff</span></span><br><span class="line">table2.append((((data[(i*<span class="number">42</span>+j+<span class="number">3</span>)%<span class="number">0x1f</span>]//<span class="number">2</span>)&amp;<span class="number">0xff</span>)+<span class="number">1</span>)&amp;<span class="number">0xff</span>)</span><br><span class="line">v6[i]+=table2[j]*input_list[j]</span><br><span class="line">table1.append(table2)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line"><span class="keyword">print</span> map(hex,table1[i])</span><br><span class="line">final=[<span class="number">0xbd360</span></span><br><span class="line">,<span class="number">0xb3ec5</span></span><br><span class="line">,<span class="number">0x8d98e</span></span><br><span class="line">,<span class="number">0xcb266</span></span><br><span class="line">,<span class="number">0xb497f</span></span><br><span class="line">,<span class="number">0xa861e</span></span><br><span class="line">,<span class="number">0x97acd</span></span><br><span class="line">,<span class="number">0xbfe57</span></span><br><span class="line">,<span class="number">0xa7d14</span></span><br><span class="line">,<span class="number">0xd4786</span></span><br><span class="line">,<span class="number">0xa3d60</span></span><br><span class="line">,<span class="number">0xac342</span></span><br><span class="line">,<span class="number">0xa9d96</span></span><br><span class="line">,<span class="number">0xb143b</span></span><br><span class="line">,<span class="number">0xa9633</span></span><br><span class="line">,<span class="number">0xb1463</span></span><br><span class="line">,<span class="number">0xc2acc</span></span><br><span class="line">,<span class="number">0xcd008</span></span><br><span class="line">,<span class="number">0xc2d4d</span></span><br><span class="line">,<span class="number">0xbcee2</span></span><br><span class="line">,<span class="number">0xb2cf6</span></span><br><span class="line">,<span class="number">0x9a886</span></span><br><span class="line">,<span class="number">0xb4e48</span></span><br><span class="line">,<span class="number">0xbd5e8</span></span><br><span class="line">,<span class="number">0xad646</span></span><br><span class="line">,<span class="number">0xd1a30</span></span><br><span class="line">,<span class="number">0xa7a1e</span></span><br><span class="line">,<span class="number">0x94a80</span></span><br><span class="line">,<span class="number">0xc6fdc</span></span><br><span class="line">,<span class="number">0x7f5f8</span></span><br><span class="line">,<span class="number">0xa93cd</span></span><br><span class="line">,<span class="number">0x88dc5</span></span><br><span class="line">,<span class="number">0xd816e</span></span><br><span class="line">,<span class="number">0x9b1aa</span></span><br><span class="line">,<span class="number">0xb2c7d</span></span><br><span class="line">,<span class="number">0xbc10e</span></span><br><span class="line">,<span class="number">0xab72d</span></span><br><span class="line">,<span class="number">0x9a7ba</span></span><br><span class="line">,<span class="number">0xcd12a</span></span><br><span class="line">,<span class="number">0xc6a1f</span></span><br><span class="line">,<span class="number">0x9f2d2</span></span><br><span class="line">,<span class="number">0xd5cbd</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">print</span> map(hex,v6)</span><br><span class="line"><span class="comment">#for i in range(42):</span></span><br><span class="line"><span class="comment">#print'(flag[%d]*table1[i][%d])+'%(i,i),</span></span><br><span class="line">s.add(flag[<span class="number">0</span>]==(ord(<span class="string">'f'</span>)^xor_table[<span class="number">0</span>]))</span><br><span class="line">s.add(flag[<span class="number">1</span>]==(ord(<span class="string">'l'</span>)^xor_table[<span class="number">1</span>]))</span><br><span class="line">s.add(flag[<span class="number">2</span>]==(ord(<span class="string">'a'</span>)^xor_table[<span class="number">2</span>]))</span><br><span class="line">s.add(flag[<span class="number">3</span>]==(ord(<span class="string">'g'</span>)^xor_table[<span class="number">3</span>]))</span><br><span class="line">s.add(flag[<span class="number">4</span>]==(ord(<span class="string">'&#123;'</span>)^xor_table[<span class="number">4</span>]))</span><br><span class="line">s.add(flag[<span class="number">41</span>]==(ord(<span class="string">'&#125;'</span>)^xor_table[<span class="number">41</span>]))</span><br><span class="line">tmp2=[<span class="number">0</span>]*<span class="number">42</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line">tmp2[i]+=flag[j]*table1[i][j]</span><br><span class="line">s.add(tmp2[i]==final[i])</span><br><span class="line"><span class="comment">#s.add((flag[0]*table1[i][0])+ (flag[1]*table1[i][1])+ (flag[2]*table1[i][2])+ (flag[3]*table1[i][3])+ (flag[4]*table1[i][4])+ (flag[5]*table1[i][5])+ (flag[6]*table1[i][6])+ (flag[7]*table1[i][7])+ (flag[8]*table1[i][8])+ (flag[9]*table1[i][9])+ (flag[10]*table1[i][10])+ (flag[11]*table1[i][11])+ (flag[12]*table1[i][12])+ (flag[13]*table1[i][13])+ (flag[14]*table1[i][14])+ (flag[15]*table1[i][15])+ (flag[16]*table1[i][16])+ (flag[17]*table1[i][17])+ (flag[18]*table1[i][18])+ (flag[19]*table1[i][19])+ (flag[20]*table1[i][20])+ (flag[21]*table1[i][21])+ (flag[22]*table1[i][22])+ (flag[23]*table1[i][23])+ (flag[24]*table1[i][24])+ (flag[25]*table1[i][25])+ (flag[26]*table1[i][26])+ (flag[27]*table1[i][27])+ (flag[28]*table1[i][28])+ (flag[29]*table1[i][29])+ (flag[30]*table1[i][30])+ (flag[31]*table1[i][31])+ (flag[32]*table1[i][32])+ (flag[33]*table1[i][33])+ (flag[34]*table1[i][34])+ (flag[35]*table1[i][35])+ (flag[36]*table1[i][36])+ (flag[37]*table1[i][37])+ (flag[38]*table1[i][38])+ (flag[39]*table1[i][39])+ (flag[40]*table1[i][40])+ (flag[41]*table1[i][41])==final[i])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> get_models(s):</span><br><span class="line">    serial = [m[flag[i]].as_long() <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">42</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(serial)):</span><br><span class="line"><span class="keyword">print</span> chr(serial[i]^xor_table[i])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">xor_table=[<span class="number">0xA0</span></span><br><span class="line">,<span class="number">0xE4</span></span><br><span class="line">,<span class="number">0xBA</span></span><br><span class="line">,<span class="number">0xFB</span></span><br><span class="line">,<span class="number">0x10</span></span><br><span class="line">,<span class="number">0xDD</span></span><br><span class="line">,<span class="number">0xAC</span></span><br><span class="line">,<span class="number">0x65</span></span><br><span class="line">,<span class="number">0x8D</span></span><br><span class="line">,<span class="number">0xB</span></span><br><span class="line">,<span class="number">0x57</span></span><br><span class="line">,<span class="number">0x1A</span></span><br><span class="line">,<span class="number">0xE4</span></span><br><span class="line">,<span class="number">0x28</span></span><br><span class="line">,<span class="number">0x96</span></span><br><span class="line">,<span class="number">0xB3</span></span><br><span class="line">,<span class="number">0xC</span></span><br><span class="line">,<span class="number">0x79</span></span><br><span class="line">,<span class="number">0x4D</span></span><br><span class="line">,<span class="number">0x80</span></span><br><span class="line">,<span class="number">0x90</span></span><br><span class="line">,<span class="number">0x99</span></span><br><span class="line">,<span class="number">0x58</span></span><br><span class="line">,<span class="number">0xFE</span></span><br><span class="line">,<span class="number">0x50</span></span><br><span class="line">,<span class="number">0xD3</span></span><br><span class="line">,<span class="number">0xF9</span></span><br><span class="line">,<span class="number">0x3C</span></span><br><span class="line">,<span class="number">0xF</span></span><br><span class="line">,<span class="number">0xC1</span></span><br><span class="line">,<span class="number">0xE3</span></span><br><span class="line">,<span class="number">0xA6</span></span><br><span class="line">,<span class="number">0x39</span></span><br><span class="line">,<span class="number">0xC3</span></span><br><span class="line">,<span class="number">0x28</span></span><br><span class="line">,<span class="number">0x75</span></span><br><span class="line">,<span class="number">0xF8</span></span><br><span class="line">,<span class="number">0xC9</span></span><br><span class="line">,<span class="number">0xC8</span></span><br><span class="line">,<span class="number">0xCD</span></span><br><span class="line">,<span class="number">0x78</span></span><br><span class="line">,<span class="number">0x26</span>]</span><br><span class="line">data=[]</span><br><span class="line">tmp=<span class="number">82</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'key is '</span>,tmp</span><br><span class="line">data.append(tmp)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x1e</span>):</span><br><span class="line">res=<span class="number">16807</span> * (tmp % <span class="number">127773</span>) - <span class="number">2836</span> * (tmp // <span class="number">127773</span>)</span><br><span class="line"><span class="comment">#print hex(abs(res))</span></span><br><span class="line"><span class="keyword">if</span>(res&lt;<span class="number">0</span>):</span><br><span class="line">tmp=res+<span class="number">0x7FFFFFFF</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tmp=res</span><br><span class="line">data.append(tmp)</span><br><span class="line"><span class="keyword">print</span> map(hex,data)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0x1f</span>):</span><br><span class="line"><span class="comment">#print "%x + %x =%x"%(data[(j+3)%0x1f],data[j],data[(j+3)%0x1f]+data[j])</span></span><br><span class="line">data[(j+<span class="number">3</span>)%<span class="number">0x1f</span>]=(data[(j+<span class="number">3</span>)%<span class="number">0x1f</span>]+data[j])&amp;<span class="number">0xffffffff</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">div2</span><span class="params">(num)</span>:</span></span><br><span class="line"><span class="keyword">return</span> num//<span class="number">2</span></span><br><span class="line"><span class="keyword">print</span> map(hex,map(div2,data))</span><br><span class="line"><span class="keyword">print</span> map(hex,data)</span><br><span class="line">table1=[]</span><br><span class="line">input=<span class="string">'flag&#123;111111111111111111111111111111111111&#125;'</span></span><br><span class="line">input_list=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line">input_list.append(ord(input[i])^xor_table[i])</span><br><span class="line">v6=[<span class="number">0</span>]*<span class="number">42</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line">table2=[]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line"><span class="comment">#print "%x + %x =%x"%(data[(j+3)%0x1f],data[j],data[(j+3)%0x1f]+data[j])</span></span><br><span class="line">data[(i*<span class="number">42</span>+j+<span class="number">3</span>)%<span class="number">0x1f</span>]=(data[(i*<span class="number">42</span>+j+<span class="number">3</span>)%<span class="number">0x1f</span>]+data[(i*<span class="number">42</span>+j)%<span class="number">0x1f</span>])&amp;<span class="number">0xffffffff</span></span><br><span class="line">table2.append((((data[(i*<span class="number">42</span>+j+<span class="number">3</span>)%<span class="number">0x1f</span>]//<span class="number">2</span>)&amp;<span class="number">0xff</span>)+<span class="number">1</span>)&amp;<span class="number">0xff</span>)</span><br><span class="line">v6[i]+=table2[j]*input_list[j]</span><br><span class="line">table1.append(table2)</span><br><span class="line">final=[<span class="number">0xbd360</span></span><br><span class="line">,<span class="number">0xb3ec5</span></span><br><span class="line">,<span class="number">0x8d98e</span></span><br><span class="line">,<span class="number">0xcb266</span></span><br><span class="line">,<span class="number">0xb497f</span></span><br><span class="line">,<span class="number">0xa861e</span></span><br><span class="line">,<span class="number">0x97acd</span></span><br><span class="line">,<span class="number">0xbfe57</span></span><br><span class="line">,<span class="number">0xa7d14</span></span><br><span class="line">,<span class="number">0xd4786</span></span><br><span class="line">,<span class="number">0xa3d60</span></span><br><span class="line">,<span class="number">0xac342</span></span><br><span class="line">,<span class="number">0xa9d96</span></span><br><span class="line">,<span class="number">0xb143b</span></span><br><span class="line">,<span class="number">0xa9633</span></span><br><span class="line">,<span class="number">0xb1463</span></span><br><span class="line">,<span class="number">0xc2acc</span></span><br><span class="line">,<span class="number">0xcd008</span></span><br><span class="line">,<span class="number">0xc2d4d</span></span><br><span class="line">,<span class="number">0xbcee2</span></span><br><span class="line">,<span class="number">0xb2cf6</span></span><br><span class="line">,<span class="number">0x9a886</span></span><br><span class="line">,<span class="number">0xb4e48</span></span><br><span class="line">,<span class="number">0xbd5e8</span></span><br><span class="line">,<span class="number">0xad646</span></span><br><span class="line">,<span class="number">0xd1a30</span></span><br><span class="line">,<span class="number">0xa7a1e</span></span><br><span class="line">,<span class="number">0x94a80</span></span><br><span class="line">,<span class="number">0xc6fdc</span></span><br><span class="line">,<span class="number">0x7f5f8</span></span><br><span class="line">,<span class="number">0xa93cd</span></span><br><span class="line">,<span class="number">0x88dc5</span></span><br><span class="line">,<span class="number">0xd816e</span></span><br><span class="line">,<span class="number">0x9b1aa</span></span><br><span class="line">,<span class="number">0xb2c7d</span></span><br><span class="line">,<span class="number">0xbc10e</span></span><br><span class="line">,<span class="number">0xab72d</span></span><br><span class="line">,<span class="number">0x9a7ba</span></span><br><span class="line">,<span class="number">0xcd12a</span></span><br><span class="line">,<span class="number">0xc6a1f</span></span><br><span class="line">,<span class="number">0x9f2d2</span></span><br><span class="line">,<span class="number">0xd5cbd</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calL</span><span class="params">()</span>:</span></span><br><span class="line">    t = []</span><br><span class="line">    tmp=[]</span><br><span class="line">    a=matrix(table1)</span><br><span class="line">    b = matrix(final)</span><br><span class="line">    L =  a.solve_right(b.T)</span><br><span class="line">    L =  L</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line">L  = calL()</span><br><span class="line"><span class="keyword">print</span> L</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> *</span><br><span class="line">xor_table=[<span class="number">0xA0</span></span><br><span class="line">,<span class="number">0xE4</span></span><br><span class="line">,<span class="number">0xBA</span></span><br><span class="line">,<span class="number">0xFB</span></span><br><span class="line">,<span class="number">0x10</span></span><br><span class="line">,<span class="number">0xDD</span></span><br><span class="line">,<span class="number">0xAC</span></span><br><span class="line">,<span class="number">0x65</span></span><br><span class="line">,<span class="number">0x8D</span></span><br><span class="line">,<span class="number">0xB</span></span><br><span class="line">,<span class="number">0x57</span></span><br><span class="line">,<span class="number">0x1A</span></span><br><span class="line">,<span class="number">0xE4</span></span><br><span class="line">,<span class="number">0x28</span></span><br><span class="line">,<span class="number">0x96</span></span><br><span class="line">,<span class="number">0xB3</span></span><br><span class="line">,<span class="number">0xC</span></span><br><span class="line">,<span class="number">0x79</span></span><br><span class="line">,<span class="number">0x4D</span></span><br><span class="line">,<span class="number">0x80</span></span><br><span class="line">,<span class="number">0x90</span></span><br><span class="line">,<span class="number">0x99</span></span><br><span class="line">,<span class="number">0x58</span></span><br><span class="line">,<span class="number">0xFE</span></span><br><span class="line">,<span class="number">0x50</span></span><br><span class="line">,<span class="number">0xD3</span></span><br><span class="line">,<span class="number">0xF9</span></span><br><span class="line">,<span class="number">0x3C</span></span><br><span class="line">,<span class="number">0xF</span></span><br><span class="line">,<span class="number">0xC1</span></span><br><span class="line">,<span class="number">0xE3</span></span><br><span class="line">,<span class="number">0xA6</span></span><br><span class="line">,<span class="number">0x39</span></span><br><span class="line">,<span class="number">0xC3</span></span><br><span class="line">,<span class="number">0x28</span></span><br><span class="line">,<span class="number">0x75</span></span><br><span class="line">,<span class="number">0xF8</span></span><br><span class="line">,<span class="number">0xC9</span></span><br><span class="line">,<span class="number">0xC8</span></span><br><span class="line">,<span class="number">0xCD</span></span><br><span class="line">,<span class="number">0x78</span></span><br><span class="line">,<span class="number">0x26</span>]</span><br><span class="line">data=[]</span><br><span class="line">tmp=<span class="number">82</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'key is '</span>,tmp</span><br><span class="line">data.append(tmp)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x1e</span>):</span><br><span class="line">res=<span class="number">16807</span> * (tmp % <span class="number">127773</span>) - <span class="number">2836</span> * (tmp // <span class="number">127773</span>)</span><br><span class="line"><span class="comment">#print hex(abs(res))</span></span><br><span class="line"><span class="keyword">if</span>(res&lt;<span class="number">0</span>):</span><br><span class="line">tmp=res+<span class="number">0x7FFFFFFF</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tmp=res</span><br><span class="line">data.append(tmp)</span><br><span class="line"><span class="comment">#print map(hex,data)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0x1f</span>):</span><br><span class="line"><span class="comment">#print "%x + %x =%x"%(data[(j+3)%0x1f],data[j],data[(j+3)%0x1f]+data[j])</span></span><br><span class="line">data[(j+<span class="number">3</span>)%<span class="number">0x1f</span>]=(data[(j+<span class="number">3</span>)%<span class="number">0x1f</span>]+data[j])&amp;<span class="number">0xffffffff</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">div2</span><span class="params">(num)</span>:</span></span><br><span class="line"><span class="keyword">return</span> num//<span class="number">2</span></span><br><span class="line"><span class="comment">#print map(hex,map(div2,data))</span></span><br><span class="line"><span class="comment">#print map(hex,data)</span></span><br><span class="line">table1=[]</span><br><span class="line">input=<span class="string">'flag&#123;111111111111111111111111111111111111&#125;'</span></span><br><span class="line">input_list=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line">input_list.append(ord(input[i])^xor_table[i])</span><br><span class="line">v6=[<span class="number">0</span>]*<span class="number">42</span></span><br><span class="line">table3=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line">table2=[]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line"><span class="comment">#print "%x + %x =%x"%(data[(j+3)%0x1f],data[j],data[(j+3)%0x1f]+data[j])</span></span><br><span class="line">data[(i*<span class="number">42</span>+j+<span class="number">3</span>)%<span class="number">0x1f</span>]=(data[(i*<span class="number">42</span>+j+<span class="number">3</span>)%<span class="number">0x1f</span>]+data[(i*<span class="number">42</span>+j)%<span class="number">0x1f</span>])&amp;<span class="number">0xffffffff</span></span><br><span class="line">table2.append((((data[(i*<span class="number">42</span>+j+<span class="number">3</span>)%<span class="number">0x1f</span>]//<span class="number">2</span>)&amp;<span class="number">0xff</span>)+<span class="number">1</span>)&amp;<span class="number">0xff</span>)</span><br><span class="line">v6[i]+=table2[j]*input_list[j]</span><br><span class="line">table3.append((((data[(i*<span class="number">42</span>+j+<span class="number">3</span>)%<span class="number">0x1f</span>]//<span class="number">2</span>)&amp;<span class="number">0xff</span>)+<span class="number">1</span>)&amp;<span class="number">0xff</span>)</span><br><span class="line">table1.append(table2)</span><br><span class="line">final=[<span class="number">0xbd360</span></span><br><span class="line">,<span class="number">0xb3ec5</span></span><br><span class="line">,<span class="number">0x8d98e</span></span><br><span class="line">,<span class="number">0xcb266</span></span><br><span class="line">,<span class="number">0xb497f</span></span><br><span class="line">,<span class="number">0xa861e</span></span><br><span class="line">,<span class="number">0x97acd</span></span><br><span class="line">,<span class="number">0xbfe57</span></span><br><span class="line">,<span class="number">0xa7d14</span></span><br><span class="line">,<span class="number">0xd4786</span></span><br><span class="line">,<span class="number">0xa3d60</span></span><br><span class="line">,<span class="number">0xac342</span></span><br><span class="line">,<span class="number">0xa9d96</span></span><br><span class="line">,<span class="number">0xb143b</span></span><br><span class="line">,<span class="number">0xa9633</span></span><br><span class="line">,<span class="number">0xb1463</span></span><br><span class="line">,<span class="number">0xc2acc</span></span><br><span class="line">,<span class="number">0xcd008</span></span><br><span class="line">,<span class="number">0xc2d4d</span></span><br><span class="line">,<span class="number">0xbcee2</span></span><br><span class="line">,<span class="number">0xb2cf6</span></span><br><span class="line">,<span class="number">0x9a886</span></span><br><span class="line">,<span class="number">0xb4e48</span></span><br><span class="line">,<span class="number">0xbd5e8</span></span><br><span class="line">,<span class="number">0xad646</span></span><br><span class="line">,<span class="number">0xd1a30</span></span><br><span class="line">,<span class="number">0xa7a1e</span></span><br><span class="line">,<span class="number">0x94a80</span></span><br><span class="line">,<span class="number">0xc6fdc</span></span><br><span class="line">,<span class="number">0x7f5f8</span></span><br><span class="line">,<span class="number">0xa93cd</span></span><br><span class="line">,<span class="number">0x88dc5</span></span><br><span class="line">,<span class="number">0xd816e</span></span><br><span class="line">,<span class="number">0x9b1aa</span></span><br><span class="line">,<span class="number">0xb2c7d</span></span><br><span class="line">,<span class="number">0xbc10e</span></span><br><span class="line">,<span class="number">0xab72d</span></span><br><span class="line">,<span class="number">0x9a7ba</span></span><br><span class="line">,<span class="number">0xcd12a</span></span><br><span class="line">,<span class="number">0xc6a1f</span></span><br><span class="line">,<span class="number">0x9f2d2</span></span><br><span class="line">,<span class="number">0xd5cbd</span></span><br><span class="line">]</span><br><span class="line">a = np.array(table1)</span><br><span class="line">tmp1=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line">tmp1.append([final[i]])</span><br><span class="line">b = np.array(tmp1)</span><br><span class="line">x = np.linalg.solve(a, b)</span><br><span class="line"><span class="keyword">print</span> x</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2020华为CTF&quot;&gt;&lt;a href=&quot;#2020华为CTF&quot; class=&quot;headerlink&quot; title=&quot;2020华为CTF&quot;&gt;&lt;/a&gt;2020华为CTF&lt;/h1&gt;&lt;p&gt;三场比赛的时候都没啥时间，匆匆看了几道题&lt;/p&gt;
&lt;h2 id=&quot;第一场&quot;&gt;&lt;a h</summary>
      
    
    
    
    
    <category term="ctf" scheme="http://pidanxu.github.io/tags/ctf/"/>
    
  </entry>
  
</feed>
